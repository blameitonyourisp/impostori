import"process";import"readline";import e from"fs";import t from"path";import{fileURLToPath as n}from"url";class r extends Error{constructor(e){super();let t="";for(const n in e)switch(n){case"name":this.name=e[n];break;case"message":t=`${e[n]}\n${t}`;break;default:{const r=`${n}: ${e[n]}`;t=`${t}${a(r,"gray",1)}\n`}}this.message=t||""}}const s=(e,{modifiers:t=[],tabs:n=0,tabSize:r=4}={})=>{let s="";for(const e of t)s=`${s}${e}`;const a=i.decorations.reset;return`${s}${" ".repeat(n*r)}${e}${a}`},a=(e,t,n=0)=>{const r=i.fgColors[t];return s(e,r?{modifiers:[r],tabs:n}:{tabs:n})},i={fgColors:{black:"[30m",red:"[31m",green:"[32m",yellow:"[33m",blue:"[34m",magenta:"[35m",cyan:"[36m",white:"[37m",gray:"[90m"},bgColors:{black:"[40m",red:"[41m",green:"[42m",yellow:"[43m",blue:"[44m",magenta:"[45m",cyan:"[46m",white:"[47m",gray:"[100m"},decorations:{reset:"[0m",bright:"[1m",dim:"[2m",underline:"[4m",blink:"[5m",reverse:"[7m",hidden:"[8m"}},o="",d="worker",l="imposter",c="vacant",p=({upper:e=1/0,lower:t=-1/0,mean:n=0,stdDev:r=1,precision:s=5,mode:a=d}={})=>{switch(e=(e-n)/r,t=(t-n)/r,s=Math.min(Math.max(s,1),100),a){case l:const n=p({upper:e,precision:s+1}),r=p({upper:t,precision:s+1});return parseFloat((n-r).toPrecision(s));case c:const a=1-p({upper:e,lower:t,mode:l,precision:s});return parseFloat(a.toPrecision(s));case o:const i=1-p({upper:t,precision:s});return parseFloat(i.toPrecision(s));default:if(e===1/0)return 1;if(e===-1/0)return 0;let[d,u]=[0,1],[f,h]=[0,0];for(;d.toPrecision(s)!==u.toPrecision(s);){let t=1;for(let e=0;e<h;e++)t*=e+1;f+=(-1)**h*e**(2*h+1)/((2*h+1)*2**h*t),d=u,u=.5+1/Math.sqrt(2*Math.PI)*f,h++}return parseFloat(u.toPrecision(s))}};class u{constructor(e=u.seed(),t=34319,n=89459){e%t!=0&&e%n!=0||e++,this.config={seed:e,primeP:t,primeQ:n,divisor:t*n},this.state={iteration:0,iteratedSeed:e}}iterate(){return this.state.iteration++,this.state.iteratedSeed=this.state.iteratedSeed**2%this.config.divisor,this.state.iteratedSeed/this.config.divisor}jump(e){for(let t=0;t<e-1;t++)this.iterate();return this.iterate()}jumpRandom(e=10,t=100){return this.jump(this.prng(e,t)-1)}prng(e=0,t=1){return u.floatToRangedInteger(this.iterate(),e,t)}shuffleArray([...e]){return Array.from({length:e.length},(()=>e.splice(this.prng(0,e.length-1),1)[0]))}shuffledIndexArray(e,t=!1){return this.shuffleArray(Array.from({length:e},((e,n)=>n+t)))}static seed(){return u.floatToRangedInteger(Math.random(),2**31,2**32-1)}static floatToRangedInteger(e,t,n){return Math.round(t+e*(n-t))}}class f{#e;#t;#n;#r;#s;constructor({length:e=16,size:t=Math.floor(6*e/8),buffer:n=new ArrayBuffer(t)}={}){this.#e=n,this.#t=0,this.#n=0,this.#r=0,this.#s=0}write(e,{size:t=f.#a(e),offset:n=this.#r,signed:r=!1}={}){return this.#i().append(e,{size:t,offset:n,signed:r}).isWriteable?this.#o(e,{size:t,offset:n,signed:r}):NaN}writeAbsolute(e,{offset:t=this.#r,signed:n=!1}={}){const r={value:f.#a(e)-1,size:5};if(!this.#i().append(r.value,{...r,offset:t}).append(e,{signed:n}).isWriteable)return NaN;this.#o(r.value,{...r,offset:t});return this.#o(e,{signed:n})}writeRelative(e,{offset:t=this.#r,signed:n=!1}={}){0===e&&(e=1);const r=f.#a(e)-this.#s,s={value:r>0?1<<r>>>0:0,size:Math.abs(r)+1};if(!this.#i().append(s.value,{...s,offset:t}).append(e,{signed:n}).isWriteable)return NaN;this.#o(s.value,{...s,offset:t});return this.#o(e,{signed:n})}writeString(e,{offset:t=this.#r}={}){const n={value:f.#a(e.length),size:5};let r=this.#i().append(n.value,{...n}).append(e.length);for(let t=0;t<e.length;t++)r=r.append(0,{size:8});if(!r.isWriteable)return"";this.#o(n.value,{...n,offset:t}),this.#o(e.length);for(const t of e)this.#o(t.charCodeAt(0),{size:8});return e}read(e,{offset:t=this.#t,signed:n=!1}={}){return this.#d().append(e,{offset:t,signed:n}).isReadable?this.#l(e,{offset:t,signed:n}):NaN}readAbsolute({offset:e=this.#t,signed:t=!1}={}){const n=this.#t,r=this.#n,s=this.#d().append(5,{offset:e});let a=0;return s.isReadable&&(a=this.#l(5,{offset:e})+1,s.append(a,{signed:t})),s.isReadable&&a?this.#l(a,{signed:t}):(this.#t=n,this.#n=r,NaN)}readRelative({offset:e=this.#t,signed:t=!1}={}){const n=this.#t,r=this.#n;let s=1;const a=this.#d().append(1,{offset:e});a.isReadable&&(s=this.#l(1,{offset:e})?1:-1);let i=0;for(;a.append(1).isReadable&&!this.#l(1);)i++;const o=r+s*i;return a.append(o,{signed:t}),a.isReadable&&o?(this.#t--,this.#l(o,{signed:t})):(this.#t=n,this.#n=r,NaN)}readString({offset:e=this.#t}={}){const t=this.#t,n=this.#n,r=this.#d().append(5,{offset:e});let s=0;r.isReadable&&(s=this.#l(5,{offset:e})),r.append(s);let a=0;if(r.isReadable&&(a=this.#l(s)),!r.isReadable||!a)return this.#t=t,this.#n=n,"";let i="";for(let e=0;e<a;e++){if(r.append(8),!r.isReadable)return this.#t=t,this.#n=n,"";i+=String.fromCharCode(this.#l(8))}return i}copy({target:e,targetStart:t=e?.writePointer||0,sourceStart:n=0,sourceEnd:s=this.bitLength}={}){if(n<0||s>this.bitLength)throw new r({name:"BitBufferError",message:"Requested bits out of source buffer range","source-start":n,"source-end":s,"source-bit-length":this.bitLength});const a=s-n,i=Math.ceil((a+t)/8);e??=new f({size:i});const o=e.bitLength-t;if(a>o)throw new r({name:"BitBufferError",message:"Source bits exceed bits available in target buffer","source-bits":a,"target-bits":o});for(let r=0;r<a;r++)e.write(this.#l(1,{offset:n+r}),{size:1,offset:t+r});return e}toString(){let e="",t=0,n=0;const r=new Uint8Array(this.#e);for(let s=0;s<3*Math.ceil(this.byteLength/3);s++){n=(n|(r[s]||0)<<16-8*t)>>>0,t=++t%3,t||(e+=f.#c(n),n=0)}return e}#i(){const e={writeable:!0,offset:this.#r},t=(n,{size:r=f.#a(n),offset:s=e.offset,signed:a=!1}={})=>{if(e.writeable){const t=Math.abs(n),i=this.bitLength-s;e.writeable=!(!a&&n<0)&&(!(f.#a(t)>r)&&(!!Number.isInteger(t)&&(!(r<0||r>32)&&!(r+(a?1:0)>i))))}return e.offset+=r,{append:t,get isWriteable(){return e.writeable}}};return{append:t,get isWriteable(){return e.writeable}}}#o(e,{size:t=f.#a(e),offset:n=this.#r,signed:r=!1}={}){const s=Math.abs(e),{view:a,byteLength:i,subBit:o}=this.#p(t,n);for(let e=0;e<i;e++){const n=a.getUint8(e);let r=0;for(let a=0;a<8;a++){const i=8*e+a;r|=(i<o||i>o+t?n<<24+a>>>31:s<<32-t+(i-o)>>>31)<<7-a}a.setUint8(e,r)}return this.#r=n+t,r&&this.#o(e>=0?1:0,{size:1}),this.#s=t,e}#d(){const e={readable:!0,offset:this.#t},t=(n,{offset:r=e.offset,signed:s=!1}={})=>{if(e.readable){const t=this.bitLength-r;e.readable=!(n<0||n>32)&&!(n+(s?1:0)>t)}return e.offset+=n,{append:t,get isReadable(){return e.readable}}};return{append:t,get isReadable(){return e.readable}}}#l(e,{offset:t=this.#t,signed:n=!1}={}){const{view:r,byteLength:s,subBit:a}=this.#p(e,t);let i=0;for(let e=0;e<s;e++){const t=24+a-8*e;i=t>=0?(i|r.getUint8(e)<<t)>>>0:(i|r.getUint8(e)>>>-t)>>>0}this.#t=t+e;const o=n&&0===this.#l(1)?-1:1;return this.#n=e,o*(i>>>32-e)}#p(e,t){const n=Math.floor(t/8),r=t-8*n,s=Math.ceil((r+e)/8);this.byteLength;return{view:new DataView(this.#e,n,s),byteLength:s,subBit:r}}get bitLength(){return this.byteLength<<3}get byteLength(){return this.#e.byteLength}get readPointer(){return this.#t}set readPointer(e){e<0||e>this.bitLength||(this.#t=e)}get lastReadSize(){return this.#n}set lastReadSize(e){e<0||e>32||(this.#n=e)}get writePointer(){return this.#r}set writePointer(e){e<0||e>this.bitLength||(this.#r=e)}get lastWriteSize(){return this.#s}set lastWriteSize(e){e<0||e>32||(this.#s=e)}static from(e){if(!e.match(/^[A-Za-z0-9\-_]*$/))throw new r({name:"BitBufferError",message:"Encoded string is not url-safe base 64 encoded","encoded-string":e});const t=new f({size:Math.ceil(3*e.length/4)}),n=/[A-Za-z0-9\-_]{1,4}/g;for(const r of e.match(n)||[]){const e=f.#u(r.padEnd(4,"A"));t.write(e,{size:24})}return t.writePointer=0,t.readPointer=0,t}static#u(e){let t=0;for(const[n,r]of e.split("").entries()){t=(t|f.#f.indexOf(r)<<18-6*n)>>>0}return t}static#c(e){let t="";for(let n=0;n<4;n++){const r=e>>>18-6*n<<26>>>26;t+=f.#f[r]}return t}static#a(e){return Math.abs(e).toString(2).length}static get#f(){return"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"}}const h=(...e)=>t=>e.reduce(((e,t)=>t(e)),t);class g{constructor(e){this.url=e}absolutePath(e){return t.join(this.__dirname,e)}relativePath(e){return t.relative(this.__dirname,e)}get __pathname(){return n(this.url)}get __dirname(){return t.dirname(this.__pathname)}get __filename(){return this.__pathname.replace(this.__dirname,"").slice(1)}}const y=(e,t)=>{const n=t.index,r=e.adjacentIndexes.optional.indexOf(n),s=e.adjacentIndexes.all.indexOf(n);if(-1===r||-1===s)return e;const a=[...e.adjacentIndexes.all];a.splice(s,1);const i=[...e.adjacentIndexes.optional];i.splice(r,1);const o={...e.adjacentIndexes.type},d=t.type.toLowerCase();o[d]=[...o[d]],o[d].splice(o[d].indexOf(n),1);const l={...e.adjacentIndexes,all:a,optional:i,type:o};return{...e,adjacentIndexes:l}},m=(e,t)=>{const n=t.index;if(e.adjacentIndexes.all.includes(n))return e;const r=[...e.adjacentIndexes.all,n],s=[...e.adjacentIndexes.optional,n],a={...e.adjacentIndexes.type},i=t.type.toLowerCase();a[i]=[...a[i],n];const o={...e.adjacentIndexes,all:r,optional:s,type:a};return{...e,adjacentIndexes:o}},w=(e,t)=>{const n=t.index,r=e.adjacentIndexes.optional.indexOf(n);if(-1===r)return e;const s=[...e.adjacentIndexes.required];s.push(n);const a=[...e.adjacentIndexes.optional];a.splice(r,1);const i={...e.adjacentIndexes,required:s,optional:a};return{...e,adjacentIndexes:i}},x=e=>[-6,-5,-1,1,5,6].flatMap((t=>{const n=e+t,r=Math.abs(n%6-e%6);return n>35||n<0||r>1?[]:[n]})),v=e=>Math.floor(e/6),I=e=>e%6,b=e=>{const t=v(e),n=I(e);return 2*Math.floor(t/2)+Math.floor(n/3)},j=(e,t)=>{if(!t.adjacencyIDs.optional.has(e.id))return t;const n=new Set(t.adjacencyIDs.optional),r=new Set(t.adjacencyIDs.deleted);n.delete(e.id),r.add(e.id);const s={...t.adjacencyIDs,optional:n,deleted:r},a=[...t.cells],i=a[e.upperIndex],o=a[e.lowerIndex];return a[e.upperIndex]=y(i,o),a[e.lowerIndex]=y(o,i),{...t,cells:a,adjacencyIDs:s}},S=(e,t)=>{if(!t.adjacencyIDs.deleted.has(e.id))return t;const n=new Set(t.adjacencyIDs.optional),r=new Set(t.adjacencyIDs.deleted);n.add(e.id),r.delete(e.id);const s={...t.adjacencyIDs,optional:n,deleted:r},a=[...t.cells],i=a[e.upperIndex],o=a[e.lowerIndex];return a[e.upperIndex]=m(i,o),a[e.lowerIndex]=m(o,i),{...t,cells:a,adjacencyIDs:s}},z=(e,t)=>{if(!t.adjacencyIDs.optional.has(e.id))return t;const n=new Set(t.adjacencyIDs.optional),r=new Set(t.adjacencyIDs.required);n.delete(e.id),r.add(e.id);const s={...t.adjacencyIDs,required:r,optional:n},a=[...t.cells],i=a[e.upperIndex],o=a[e.lowerIndex];return a[e.upperIndex]=w(i,o),a[e.lowerIndex]=w(o,i),{...t,cells:a,adjacencyIDs:s}},P=(...e)=>{let t,n,r;if(e.length>1){n=Math.min(...e),t=Math.max(...e);const s=v(n),[a,i]=[I(n),I(t)];r=16*s+6*a-5*i+5}else{r=e[0];const s=r%16,a=Math.floor(r/16),i=s%5+5*(s%5?0:1)*Math.floor(s/10);n=6*a+i,t=n+[1,6,5][1+i-(1+(16*a+6*i-r)/5)]}const s=n.toString().padStart(2,"0")+t.toString().padStart(2,"0");return{upperIndex:t,lowerIndex:n,id:r,string:s}},k={detective:"detective",worker:"worker",imposter:"imposter",vacant:"vacant"},$=(e,t)=>(e={...e,type:t},t===k.detective?E(e):e),E=e=>{const t=[...e.adjacentIndexes.type.vacant],n=e.adjacentIndexes.type.imposter.length,r={...e.adjacentIndexes.type,imposter:[...e.adjacentIndexes.type.imposter,...t.splice(0,e.value-n)],vacant:t},s={...e.adjacentIndexes,type:r};return{...e,adjacentIndexes:s}},M=(e,t,n=null,r=!1)=>{if(n??=e.typeIndexes[t][0],!n&&0!==n)return[n];const s=new Set([n]);for(const n of s.values()){const a=e.cells[n],i=r?[...a.adjacentIndexes.all]:[...a.adjacentIndexes.type[t]];for(const n of a.adjacentIndexes.type.vacant){const r=e.cells[n],s=new Set;for(const e of r.candidates)s.add(e.type);const a=()=>t===k.worker,o=()=>1===s.size;s.has(t)&&(a()||o())&&i.push(n)}for(const e of i)s.add(e)}return[...s.values()]},A=(e,t)=>{let n=new Set(e.typeIndexes[t].map((e=>e)));if(!n.size&&t===k.worker){n=new Set;for(const r of e.typeIndexes.vacant){e.cells[r].candidates.map((e=>e.type)).includes(t)&&n.add(r)}}const r=[];for(;n.size;){const s=n.values().next().value,a=M(e,t,s);for(const e of a)n.delete(e);r.push(a)}return r},R=(e,t)=>{const n=[];(t={...t,cells:[...t.cells]}).cells[e.index]=e,t=q(e,t);for(const r of e.adjacentIndexes.all){let s=t.cells[r];t.isGenerating&&s.type===k.detective&&e.type===k.imposter&&!s.adjacentIndexes.type.imposter.includes(e.index)&&n.push(s.index),s=D(e,s),t.cells[r]=s}for(const r of n){const n=t.cells[r],s=P(e.index,n.index);e=(t=j(s,t)).cells[e.index]}if(t.isGenerating&&e.type===k.detective){let n=[...e.adjacentIndexes.type.imposter];for(const e of n){const n=t.cells[e];if(n.type===k.vacant){const e=$(n,k.imposter);t=R(e,t)}}for(n=n.sort(((e,n)=>{const r=t.cells[e].adjacentIndexes.all.length,s=t.cells[n].adjacentIndexes.all.length;return r>s?1:r<s?-1:t.random.shuffleArray([1,-1])[0]}));e.value<n.length;){const r=n[0],s=P(e.index,r);n=(e=(t=j(s,t)).cells[e.index]).adjacentIndexes.type.imposter}}if(!t.isGenerating){if(e.type===k.detective){const n=[...e.adjacentIndexes.all];for(const e of n){let n=t.cells[e];const r=n.candidates.filter((e=>e.type!==k.detective));n={...n,candidates:r},t.cells[e]=n}}6===t.typeIndexes.detective.length?t=L(t,k.detective):12===t.typeIndexes.worker.length?t=L(t,k.worker):18===t.typeIndexes.imposter.length&&(t=L(t,k.imposter))}return t},L=(e,t)=>{e={...e,cells:[...e.cells]};for(let n of e.cells){const r=n.candidates.filter((e=>e.type!==t));n={...n,candidates:r},e.cells[n.index]=n}return e},D=(e,t)=>{const n={...t.adjacentIndexes,type:_(e,t)};return{...t,adjacentIndexes:n}},q=(e,t)=>({...t,typeIndexes:_(e,t)}),_=(e,t)=>{const n={detective:[...(t=t.typeIndexes||t.adjacentIndexes.type).detective],worker:[...t.worker],imposter:[...t.imposter],vacant:[...t.vacant]},r=n.vacant.indexOf(e.index);return-1!==r&&(n.vacant.splice(r,1),n[e.type.toLowerCase()].push(e.index)),n},C=e=>{e=h(N,W,V)(e);for(const t of e.typeIndexes.detective){const n=e.cells[t];for(const r of n.adjacentIndexes.type.imposter){const n=P(t,r);e=z(n,e)}}return e},N=e=>{const t=e.random.shuffledIndexArray(36),n=Array(6).fill(6);for(;n.reduce(((e,t)=>e+t),0)>18;)n.unshift(e.random.prng(1,6)),n.pop();for(let r=0;6!==e.typeIndexes.detective.length&&r<36;r++){const s=t[r],a=e.cells[s];if(O(a,n)){const t=$(a,k.detective);e=R(t,e),n.splice(n.indexOf(a.value),1)}}return e},O=(e,t)=>{const n=e.adjacentIndexes.type,r=e.value-n.imposter.length,s=e.value+(e.adjacentIndexes.all.length-2);return e.type===k.vacant&&!n.detective.length&&r<=n.vacant.length&&s>=n.imposter.length&&t.includes(e.value)},W=e=>{const t=e.random.shuffledIndexArray(36);let n;for(let r=0;!n&&r<36;r++){const s=t[r],a=e.cells[s],i=B(a,e);if(i.valid){({continuosIndexes:n}=i);break}}if(n)for(const t of n.splice(0,12)){const n=e.cells[t],r=$(n,k.worker);e=R(r,e)}return e},B=(e,t)=>{const n=M(t,k.vacant,e.index);return{valid:e.type===k.vacant&&n.length>=12,continuosIndexes:n}},V=e=>{for(const t of e.typeIndexes.vacant){const n=e.cells[t];if(n.type===k.vacant){const t=$(n,k.imposter);e=R(t,e)}}return e},G=e=>{for(const t of e.cells)if(t.type===k.imposter){if(new Set(t.adjacentIndexes.all.map((t=>e.cells[t].value))).size<2)return!1}return 0===e.typeIndexes.vacant.length&&6===e.typeIndexes.detective.length&&12===e.typeIndexes.worker.length&&18===e.typeIndexes.imposter.length},T=e=>{for(let t=0;t<36;t++){const n=e.cells[t];if(!n.value&&!n.candidates.length)return!1}return U(e)&&F(e)&&J(e)},U=e=>{const t=A(e,k.detective);if(Math.max(...t.map((e=>e.length)))>1)return!1;for(const t of e.typeIndexes.detective){const n=e.cells[t];let r=n.adjacentIndexes.type.imposter.length,s=n.adjacentIndexes.type.imposter.length;for(const t of n.adjacentIndexes.type.vacant){const n=e.cells[t],a=new Set;for(const e of n.candidates)a.add(e.type);a.has(k.imposter)&&(1===a.size&&r++,s++)}if(n.value<r||n.value>s)return!1}return e.typeIndexes.detective.length<=6&&Z(e,k.detective)>=6},F=e=>{const t=A(e,k.worker);return!(Math.max(...t.map((e=>e.length)))<12)&&(e.typeIndexes.worker.length<=12&&Z(e,k.worker)>=6)},J=e=>{const t=A(e,k.imposter);if(Math.max(...t.map((e=>e.length)))>=7)return!1;for(const t of e.typeIndexes.imposter){const n=e.cells[t],r=n.hints.imposter.filter((e=>e!==n.value)),s=new Set;for(const t of n.adjacentIndexes.all){const n=e.cells[t],r=n.value?[n.value]:n.candidates.map((e=>e.value));for(const e of r)s.add(e)}if(!s.has(r[0])||!s.has(r[1]))return!1}return e.typeIndexes.imposter.length<=18&&Z(e,k.imposter)>=6},Z=(e,t)=>{let n=0;for(const r of e.cells)if(r.type===t)n++;else if(r.type===k.vacant){r.candidates.map((e=>e.type)).includes(t)&&n++}return n},Q=(e,t)=>{const n=t.shuffleArray(x(e));return{index:e,row:v(e),column:I(e),box:b(e),candidates:t.shuffledIndexArray(6,!0).map((e=>({value:e,type:k.vacant}))),clientCandidates:[],value:0,clientValue:0,type:k.vacant,hints:{detective:[],worker:[],imposter:[]},adjacentIndexes:{all:n,required:[],optional:n,type:{detective:[],worker:[],imposter:[],vacant:n}}}},H=(e,t)=>{let n=e.cells[t];const r=e.random.shuffledIndexArray(6,!0),s=[];if(n.type===k.imposter){const t=new Set;for(const r of n.adjacentIndexes.all){const n=e.cells[r];t.add(n.value)}const a=e.random.shuffleArray([...t.values()]).splice(0,2);for(let e=0;e<6;e++){const t=r[e];t===n.value||a.includes(t)||s.push(t)}s.push(...a)}else for(let e=0;e<6;e++){const t=r[e];t!==n.value&&s.push(t)}const a=n.type===k.detective?0:n.type===k.worker?e.random.prng(1,2):e.random.prng(3,5);s.splice(a,0,n.value);const i=s.splice(0,1),o=s.splice(0,2).sort(),d=s.splice(0,3).sort();return n={...n,hints:{detective:i,worker:o,imposter:d}},n},K=e=>{e={...e,cells:[...e.cells]};for(let t=0;t<36;t++){const n=H(e,t);if(e.cells[t]=n,n.type===k.imposter){const t=new Set(n.hints.imposter.filter((e=>e!==n.value)));for(const r of n.adjacentIndexes.required){const n=e.cells[r];t.delete(n.value)}for(const r of n.adjacentIndexes.all){const s=e.cells[r];if(t.has(s.value)){const a=P(n.index,r);e=z(a,e),t.delete(s.value)}}}}return e},X=(e,t=!1)=>{const n=Array.from({length:6},((t,n)=>{const r=n+1;return{value:r,type:e.hints.detective.includes(r)?k.detective:e.hints.worker.includes(r)?k.worker:k.imposter}})),r=k.vacant,s={detective:[],worker:[],imposter:[],vacant:[...e.adjacentIndexes.all]},a={...e.adjacentIndexes,type:s};return t?{...e,candidates:n,value:0,type:r,adjacentIndexes:a}:{...e,candidates:n}},Y=e=>X(e,!1),ee=e=>X(e,!0),te=e=>{const t=[...e.candidates.sort(((e,t)=>e.value-t.value))],n={};for(const t of Object.keys(e.hints))n[t]=[...e.hints[t].sort(((e,t)=>e-t))];const r={};for(const t of Object.keys(e.adjacentIndexes))if("type"!==t)r[t]=[...e.adjacentIndexes[t].sort(((e,t)=>e-t))];else{r.type={};for(const t of Object.keys(e.adjacentIndexes.type))r.type[t]=[...e.adjacentIndexes.type[t].sort(((e,t)=>e-t))]}return{...e,candidates:t,hints:n,adjacentIndexes:r}},ne=(e,t=!1)=>{const n={detective:[],worker:[],imposter:[],vacant:Array.from({length:36},((e,t)=>t))};e=t?{...e,typeIndexes:n,cells:[...e.cells],isGenerating:!1}:{...e,cells:[...e.cells],isGenerating:!1};for(const n of e.cells)e.cells[n.index]=X(n,t);return e},re=e=>ne(e,!1),se=e=>ne(e,!0),ae=e=>{const t={};for(const n of Object.keys(e.typeIndexes))t[n]=[...e.typeIndexes[n].sort(((e,t)=>e-t))];const n={required:new Set,optional:new Set,deleted:new Set};for(let t=0;t<85;t++)e.adjacencyIDs.required.has(t)?n.required.add(t):e.adjacencyIDs.optional.has(t)?n.optional.add(t):n.deleted.add(t);e={...e,cells:[...e.cells],typeIndexes:t,adjacencyIDs:n};for(const t of e.cells)e.cells[t.index]=te(t);return e},ie=e=>{const t=[...e.candidates],n=t.pop(),r=n?.value,s=n?.type;return{...e,value:r,type:s,candidates:t}},oe=e=>Array.from({length:e.candidates.length},(()=>e=ie(e))),de=(e,t)=>{const{row:n,column:r,box:s,value:a}=e;(t={...t,cells:[...t.cells]}).cells[e.index]=e;const i=[...le(n),...ce(r),...pe(s)];for(const e of i){let n=t.cells[e];const r=n.candidates.filter((e=>e.value!==a));n={...n,candidates:r},t.cells[e]=n}if(!t.isGenerating)for(const n of e.adjacentIndexes.all){let e=t.cells[n];const r=e.candidates.filter((e=>e.value!==a));e={...e,candidates:r},t.cells[n]=e}return t},le=e=>{const t=Array(6);for(let n=0;n<6;n++)t[n]=6*e+n;return t},ce=e=>{const t=Array(6);for(let n=0;n<6;n++)t[n]=6*n+e;return t},pe=e=>{const t=Array(6);for(let n=0;n<6;n++){const r=e%2,s=Math.floor(e/2),a=n%3,i=Math.floor(n/3);t[n]=3*r+12*s+a+6*i}return t},ue=e=>{const t=new Set;for(let n=0;n<36;n++){const r=e.cells[n],s=r.value?[r.value]:r.candidates.map((e=>e.value));if(!s)return!1;for(let e=0;e<s.length;e++){const n=6*r.row+s[e],a=36+6*r.column+s[e],i=72+6*r.box+s[e];t.add(n).add(a).add(i)}}return 108===t.size},fe=e=>{const t=[e];let n=0;const r=e.random.shuffledIndexArray(36);for(let s=0;s<36;s++){const a=r[s],i=ie(e.cells[a]);if(e=de(i,e),ue(e))t.push(e);else{let n=e.cells[a];for(;!n.candidates.length;)n=(e=t.pop()).cells[r[--s]];n.value=0,(e=t.slice(-1)[0]).cells[n.index]=n,--s}if(++n>1e4)return fe(t[0])}return e},he=(e,t)=>{const n=e.cells[t],r=oe(n),s=[];for(const t of r){let n=de(t,e);ue(n)&&(n=R(t,n),T(n)&&s.push(n))}return s},ge=e=>{let t=0,n=[e];for(let e=0;e<36;e++){t+=n.length;const e=[];for(const t of n){const n=[...t.typeIndexes.vacant].sort(((e,n)=>{const r=t.cells[e].candidates.length,s=t.cells[n].candidates.length;return r>s?1:r<s?-1:t.random.shuffleArray([1,-1])[0]}));e.push(...he(t,n[0]))}n=e}return{grids:n,rawEntropy:t}},ye=e=>{const t=(e=h(me,we)(e)).random.iterate();for(const n of e.adjacencyIDs.optional){const r=P(n);e=e.random.iterate()>t?z(r,e):j(r,e)}return e},me=e=>{const t=[];for(const n of e.typeIndexes.imposter){const r=e.cells[n];for(const s of r.adjacentIndexes.optional){const r=P(n,s),a=j(r,e);xe(a)?(e=a,t.push(r)):e=z(r,e)}}for(const n of t){const t=S(n,e);T(t)&&(e=t)}return e},we=e=>{const t=[];for(const n of e.typeIndexes.worker){const r=e.cells[n],s=r.adjacentIndexes.type.worker.filter((e=>r.adjacentIndexes.optional.includes(e)));for(const r of s){const s=P(n,r),a=j(s,e);xe(a)?(e=a,t.push(s)):e=z(s,e)}}for(const n of t)e=S(n,e);return e},xe=e=>{for(const t of e.cells)if(t.type===k.imposter){if(new Set(t.adjacentIndexes.all.map((t=>e.cells[t].value))).size<2)return!1}return 36===M(e,k.vacant,0,!0).length},ve=e=>{let t=e;for(const n of e.cells)for(const r of n.adjacentIndexes.all){if(e.cells[r].value===n.value){const e=P(r,n.index);t=j(e,t)}}return t},Ie=e=>{const t=Array.from({length:36},((t,n)=>Q(n,e))),n={detective:[],worker:[],imposter:[],vacant:e.shuffledIndexArray(36)},r=new Set;t.forEach((e=>{e.adjacentIndexes.all.forEach((t=>{const n=P(e.index,t);r.add(n.id)}))}));return{cells:t,typeIndexes:n,adjacencyIDs:{required:new Set,optional:r,deleted:new Set},random:e,isGenerating:!0}},be=e=>{let t=0;let n,r;e:do{n=h(Ie,fe,ve)(e);do{if(r=C(n),++t>85){e.jumpRandom(),t=0;continue e}}while(!G(r));n=h(ye,K)(r)}while(!T(n));const s=h(se,ge)(n);if(1!==s.grids.length||!je(n,s.grids[0]))return e.jumpRandom(),be(e);const{rawEntropy:a}=s;return n=h(re,ae)(n),{grid:n,rawEntropy:a}},je=(e,t)=>!0,Se=e=>{const t=new f({size:11});for(let n=0;n<85;n++){const r=e.adjacencyIDs.required.has(n);t.write(r?1:0)}return t},ze=e=>{const t={required:new Set,optional:new Set,deleted:new Set};for(let n=0;n<85;n++)e.read(1)?t.required.add(n):t.deleted.add(n);return t},Pe=e=>{let t=new f({size:3});const{value:n,clientValue:r,hints:s}=e,a=[n,r,...s.detective,...s.worker];for(const e of a)t.write(e,{size:3});if(e.clientCandidates.length&&6!==e.clientCandidates.length){t.write(1,{size:1});const n=e.clientCandidates.map((({value:e})=>e));let r=0;for(let e=0;e<6;e++)n.includes(e+1)&&(r|=1<<e);t.write(r,{size:6})}else t.write(0,{size:1});const i=Math.ceil(t.writePointer/8);return t=t.copy({target:new f({size:i}),sourceEnd:t.writePointer}),t},ke=(e,t)=>{const n=x(t),r={index:t,row:v(t),column:I(t),box:b(t),candidates:[],clientCandidates:[],value:e.read(3),clientValue:e.read(3),type:k.vacant,hints:{detective:[e.read(3)],worker:[e.read(3),e.read(3)],imposter:[]},adjacentIndexes:{all:n,required:[],optional:n,type:{detective:[],worker:[],imposter:[],vacant:[]}}};r.type=r.hints.detective.includes(r.value)?k.detective:r.hints.worker.includes(r.value)?k.worker:k.imposter,r.hints.imposter=[1,2,3,4,5,6].filter((e=>!r.hints.detective.includes(e)&&!r.hints.worker.includes(e)));let s=parseInt("111111",2);e.read(1)&&(s=e.read(6));for(let e=0;e<6;e++)r.candidates.push($e(r,e+1)),s<<31-e>>>31&&r.clientCandidates.push($e(r,e+1));return{...r}},$e=(e,t)=>({value:t,type:e.hints.detective.includes(t)?k.detective:e.hints.worker.includes(t)?k.worker:k.imposter}),Ee=e=>{e=ae(e);let t=new f({size:128});for(const n of e.cells){const e=Pe(n);e.copy({target:t,sourceEnd:e.writePointer})}const n=Se(e);n.copy({target:t,sourceEnd:n.writePointer});const r=Math.ceil(t.writePointer/8);return t=t.copy({target:new f({size:r}),sourceEnd:t.writePointer}),t},Me=(e,t)=>{const n={detective:[],worker:[],imposter:[],vacant:[]},r=[];for(let t=0;t<36;t++){const s=ke(e,t);n[s.type].push(t),r.push(s)}r.forEach((e=>{e.adjacentIndexes.all.forEach((t=>{const{type:n}=r[t];e.adjacentIndexes.type[n].push(t)}))}));const s=ze(e);let a={cells:r,typeIndexes:n,adjacencyIDs:{required:new Set,optional:new Set(Array.from({length:85},((e,t)=>t))),deleted:new Set},random:new u(t),isGenerating:!1};for(const e of a.adjacencyIDs.optional)a=s.required.has(e)?z(P(e),a):j(P(e),a);return a=ae(a),a},Ae=e=>{let t=new f({size:128});t.writeString(e.version.puzzle),t.writeString(e.version.repository),t.writeAbsolute(e.seed);const n=Ee(e.grid);n.copy({target:t,sourceEnd:n.writePointer}),t.writeAbsolute(e.rawEntropy),t.write(e.normalizedEntropy,{size:10}),t.write(e.uniformEntropy,{size:10});const r=Math.ceil(t.writePointer/8);return t=t.copy({target:new f({size:r}),sourceEnd:t.writePointer}),t.toString()},Re=e=>{const t=f.from(e),n={puzzle:t.readString(),repository:t.readString()},r=t.readAbsolute(),s={version:n,seed:r,grid:Me(t,r),rawEntropy:t.readAbsolute(),normalizedEntropy:t.read(10),uniformEntropy:t.read(10)},a=Oe(s.uniformEntropy),i=We(a);return{...s,rating:a,grade:i,serializedString:e}},Le="1.0.0",De={beginner:"beginner",easy:"easy",medium:"medium",hard:"hard",expert:"expert"},qe=e=>{const t=new u(e),{grid:n,rawEntropy:r}=be(t),s={version:{puzzle:Le,repository:_e()},seed:t.config.seed,grid:n,rawEntropy:r};return s.normalizedEntropy=Ce(s.rawEntropy),s.uniformEntropy=Ne(s.normalizedEntropy),s.rating=Oe(s.uniformEntropy),s.grade=We(s.rating),s.grid.random=new u(s.seed),{...s,serializedString:Ae(s)}},_e=()=>{const t=new g(import.meta.url).absolutePath("../../../../package.json"),{packageObject:n,packageError:s}=((t="package.json")=>{const n=e=>{throw new r({name:"PackageJsonError",message:"Error encountered parsing repository package.json file",path:`${process.cwd()}/${t}`,detail:e.message,"caller-stack":e.stack})};let s;try{s=JSON.parse(e.readFileSync(t).toString())}catch(e){n(e)}return{packageObject:s,packageError:n}})(t),{version:a}=n;if(!a){s(new Error("Version unset or unrecognized, no package version found"))}return a},Ce=e=>{const t=512+256*(Math.log(e)-6.94);return Math.min(Math.max(Math.round(t),0),1024)},Ne=e=>{const t=p({upper:e,mean:512,stdDev:187});return Math.round(1024*t)},Oe=e=>Math.ceil(e/10.24),We=e=>e<=20?De.beginner:e<=40?De.easy:e<=60?De.medium:e<=80?De.hard:De.expert,Be=e=>{for(let t=0;t<6;t++)Ve(e,t),Ge(e,t),Te(e,t),Ue(e,t)},Ve=(e,t)=>{const n=[];for(let r=0;r<6;r++){const s=6*t+r,a=e.cells[s],[i]=a.hints.detective,o=[i===a.value?"(":" ",i===a.value?")":" "];let d=`${a.type===k.vacant?"V  ":""}${o[0]}${i||0}${o[1]}`.padStart(7);d=d.padEnd(11);const l=r?"":"  ";n.push(`${l}┌${d}┐  `)}console.log(n.join(""))},Ge=(e,t)=>{const n=[];for(let r=0;r<6;r++){const s=6*t+r,a=e.cells[s],[i,o]=a.hints.worker,d=[i===a.value?"(":" ",i===a.value?")":" ",o===a.value?"(":" ",o===a.value?")":" "],l=`${d[0]}${i||0}${d[1]}`,c=`${d[2]}${o||0}${d[3]}`;let p=l.padStart(5);p+=` ${c}`,p=p.padEnd(11);const u=a.adjacentIndexes.all.includes(s+1)?"──":"  ",f=r?"":"  ";n.push(`${f}│${p}│${u}`)}console.log(n.join(""))},Te=(e,t)=>{const n=[];for(let r=0;r<6;r++){const s=6*t+r,a=e.cells[s],[i,o,d]=a.hints.imposter,l=[i===a.value?"(":" ",i===a.value?")":" ",o===a.value?"(":" ",o===a.value?")":" ",d===a.value?"(":" ",d===a.value?")":" "],c=`${l[0]}${i||0}${l[1]}`,p=`${l[2]}${o||0}${l[3]}`,u=`${l[4]}${d||0}${l[5]}`;let f=c.padStart(3);f+=` ${p} ${u}`,f=f.padEnd(11);const h=r?"":"  ";n.push(`${h}└${f}┘  `)}console.log(n.join(""))},Ue=(e,t)=>{const n=[];for(let r=0;r<6;r++){const s=6*t+r,a=e.cells[s],i=a.adjacentIndexes.all.includes(s+5),o=a.adjacentIndexes.all.includes(s+6);let d=i?" ╱":"  ";d=d.padEnd(8),d+=o?"│":" ";const l=d.padEnd(15);n.push(`${l}`)}console.log(n.join("")),n.forEach(((e,t)=>{n[t]=`${e[1]} ${e.slice(2)}`})),console.log(n.join(""))};export{k as CELL_TYPES,De as IMPOSTORI_GRADES,Le as PUZZLE_VERSION,m as addCellAdjacency,S as addGridAdjacency,A as allContinuosTypeIndexes,G as completedGridTypes,M as continuosTypeIndexes,ze as deserializeAdjacencies,ke as deserializeCell,Me as deserializeGrid,Re as deserializeImpostori,H as fillCellHints,$ as fillCellType,ie as fillCellValue,K as fillGridHints,C as fillGridTypes,fe as fillGridValues,oe as forkCellValue,Q as generateEmptyCell,Ie as generateEmptyGrid,be as generateGrid,qe as generateImpostori,P as getAdjacencyData,x as getAdjacentIndexes,b as getBox,$e as getCandidate,I as getColumn,We as getGradeString,Oe as getRating,v as getRow,ee as hardResetCell,se as hardResetGrid,Be as printGrid,R as propagateCellType,de as propagateCellValue,ye as pruneGridAdjacencies,y as removeCellAdjacency,j as removeGridAdjacency,ve as removeTwins,w as requireCellAdjacency,z as requireGridAdjacency,X as resetCell,ne as resetGrid,Se as serializeAdjacencies,Pe as serializeCell,Ee as serializeGrid,Ae as serializeImpostori,Y as softResetCell,re as softResetGrid,he as solveCell,ge as solveGrid,te as sortCell,ae as sortGrid,T as validateGridTypes,ue as validateGridValues};
