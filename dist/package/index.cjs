"use strict";require("process"),require("readline"),require("path"),require("url");class e extends Error{constructor(e){super();let t="";for(const s in e)switch(s){case"name":this.name=e[s];break;case"message":t=`${e[s]}\n${t}`;break;default:{const r=`${s}: ${e[s]}`;t=`${t}${n(r,"gray",1)}\n`}}this.message=t||""}}const t=(e,{modifiers:t=[],tabs:n=0,tabSize:r=4}={})=>{let a="";for(const e of t)a=`${a}${e}`;const o=s.decorations.reset;return`${a}${" ".repeat(n*r)}${e}${o}`},n=(e,n,r=0)=>{const a=s.fgColors[n];return t(e,a?{modifiers:[a],tabs:r}:{tabs:r})},s={fgColors:{black:"[30m",red:"[31m",green:"[32m",yellow:"[33m",blue:"[34m",magenta:"[35m",cyan:"[36m",white:"[37m",gray:"[90m"},bgColors:{black:"[40m",red:"[41m",green:"[42m",yellow:"[43m",blue:"[44m",magenta:"[45m",cyan:"[46m",white:"[47m",gray:"[100m"},decorations:{reset:"[0m",bright:"[1m",dim:"[2m",underline:"[4m",blink:"[5m",reverse:"[7m",hidden:"[8m"}};class r{constructor(e=r.seed(),t=34319,n=89459){e%t!=0&&e%n!=0||e++,this.config={seed:e,primeP:t,primeQ:n,divisor:t*n},this.state={iteration:0,iteratedSeed:e}}iterate(){return this.state.iteration++,this.state.iteratedSeed=this.state.iteratedSeed**2%this.config.divisor,this.state.iteratedSeed/this.config.divisor}prng(e=0,t=1){return r.floatToRangedInteger(this.iterate(),e,t)}shuffleArray([...e]){return Array.from({length:e.length},(()=>e.splice(this.prng(0,e.length-1),1)[0]))}shuffledIndexArray(e,t=!1){return this.shuffleArray(Array.from({length:e},((e,n)=>n+t)))}static seed(){return r.floatToRangedInteger(Math.random(),2**31,2**32-1)}static floatToRangedInteger(e,t,n){return Math.round(t+e*(n-t))}}class a{#e;#t;#n;#s;#r;constructor({length:e=16,size:t=Math.floor(6*e/8),buffer:n=new ArrayBuffer(t)}={}){this.#e=n,this.#t=0,this.#n=0,this.#s=0,this.#r=0}write(e,{size:t=a.#a(e),offset:n=this.#s,signed:s=!1}={}){return this.#o().append(e,{size:t,offset:n,signed:s}).isWriteable?this.#i(e,{size:t,offset:n,signed:s}):NaN}writeAbsolute(e,{offset:t=this.#s,signed:n=!1}={}){const s={value:a.#a(e),size:5};if(!this.#o().append(s.value,{...s,offset:t}).append(e,{signed:n}).isWriteable)return NaN;this.#i(s.value,{...s,offset:t});return this.#i(e,{signed:n})}writeRelative(e,{offset:t=this.#s,signed:n=!1}={}){0===e&&(e=1);const s=a.#a(e)-this.#r,r={value:s>0?1<<s>>>0:0,size:Math.abs(s)+1};if(!this.#o().append(r.value,{...r,offset:t}).append(e,{signed:n}).isWriteable)return NaN;this.#i(r.value,{...r,offset:t});return this.#i(e,{signed:n})}writeString(e,{offset:t=this.#s}={}){const n={value:a.#a(e.length),size:5};let s=this.#o().append(n.value,{...n}).append(e.length);for(let t=0;t<e.length;t++)s=s.append(0,{size:8});if(!s.isWriteable)return"";this.#i(n.value,{...n,offset:t}),this.#i(e.length);for(const t of e)this.#i(t.charCodeAt(0),{size:8});return e}read(e,{offset:t=this.#t,signed:n=!1}={}){return this.#l().append(e,{offset:t,signed:n}).isReadable?this.#d(e,{offset:t,signed:n}):NaN}readAbsolute({offset:e=this.#t,signed:t=!1}={}){const n=this.#t,s=this.#n,r=this.#l().append(5,{offset:e});let a=0;return r.isReadable&&(a=this.#d(5,{offset:e}),r.append(a,{signed:t})),r.isReadable&&a?this.#d(a,{signed:t}):(this.#t=n,this.#n=s,NaN)}readRelative({offset:e=this.#t,signed:t=!1}={}){const n=this.#t,s=this.#n;let r=1;const a=this.#l().append(1,{offset:e});a.isReadable&&(r=this.#d(1,{offset:e})?1:-1);let o=0;for(;a.append(1).isReadable&&!this.#d(1);)o++;const i=s+r*o;return a.append(i,{signed:t}),a.isReadable&&i?(this.#t--,this.#d(i,{signed:t})):(this.#t=n,this.#n=s,NaN)}readString({offset:e=this.#t}={}){const t=this.#t,n=this.#n,s=this.#l().append(5,{offset:e});let r=0;s.isReadable&&(r=this.#d(5,{offset:e})),s.append(r);let a=0;if(s.isReadable&&(a=this.#d(r)),!s.isReadable||!a)return this.#t=t,this.#n=n,"";let o="";for(let e=0;e<a;e++){if(s.append(8),!s.isReadable)return this.#t=t,this.#n=n,"";o+=String.fromCharCode(this.#d(8))}return o}copy({target:t,targetStart:n=t?.writePointer||0,sourceStart:s=0,sourceEnd:r=this.bitLength}={}){if(s<0||r>this.bitLength)throw new e({name:"BitBufferError",message:"Requested bits out of source buffer range","source-start":s,"source-end":r,"source-bit-length":this.bitLength});const o=r-s,i=Math.ceil((o+n)/8);t??=new a({size:i});const l=t.bitLength-n;if(o>l)throw new e({name:"BitBufferError",message:"Source bits exceed bits available in target buffer","source-bits":o,"target-bits":l});for(let e=0;e<o;e++)t.write(this.#d(1,{offset:s+e}),{size:1,offset:n+e});return t}toString(){let e="",t=0,n=0;const s=new Uint8Array(this.#e);for(let r=0;r<3*Math.ceil(this.byteLength/3);r++){n=(n|(s[r]||0)<<16-8*t)>>>0,t=++t%3,t||(e+=a.#c(n),n=0)}return e}#o(){const e={writeable:!0,offset:this.#s},t=(n,{size:s=a.#a(n),offset:r=e.offset,signed:o=!1}={})=>{if(e.writeable){const t=Math.abs(n),i=this.bitLength-r;e.writeable=!(!o&&n<0)&&(!(a.#a(t)>s)&&(!!Number.isInteger(t)&&(!(s<0||s>32)&&!(s+(o?1:0)>i))))}return e.offset+=s,{append:t,get isWriteable(){return e.writeable}}};return{append:t,get isWriteable(){return e.writeable}}}#i(e,{size:t=a.#a(e),offset:n=this.#s,signed:s=!1}={}){const r=Math.abs(e),{view:o,byteLength:i,subBit:l}=this.#p(t,n);for(let e=0;e<i;e++){const n=o.getUint8(e);let s=0;for(let a=0;a<8;a++){const o=8*e+a;s|=(o<l||o>l+t?n<<24+a>>>31:r<<32-t+(o-l)>>>31)<<7-a}o.setUint8(e,s)}return this.#s=n+t,s&&this.#i(e>=0?1:0,{size:1}),this.#r=t,e}#l(){const e={readable:!0,offset:this.#t},t=(n,{offset:s=e.offset,signed:r=!1}={})=>{if(e.readable){const t=this.bitLength-s;e.readable=!(n<0||n>32)&&!(n+(r?1:0)>t)}return e.offset+=n,{append:t,get isReadable(){return e.readable}}};return{append:t,get isReadable(){return e.readable}}}#d(e,{offset:t=this.#t,signed:n=!1}={}){const{view:s,byteLength:r,subBit:a}=this.#p(e,t);let o=0;for(let e=0;e<r;e++){const t=24+a-8*e;o=t>=0?(o|s.getUint8(e)<<t)>>>0:(o|s.getUint8(e)>>>-t)>>>0}this.#t=t+e;const i=n&&0===this.#d(1)?-1:1;return this.#n=e,i*(o>>>32-e)}#p(e,t){const n=Math.floor(t/8),s=t-8*n,r=Math.ceil((s+e)/8);this.byteLength;return{view:new DataView(this.#e,n,r),byteLength:r,subBit:s}}get bitLength(){return this.byteLength<<3}get byteLength(){return this.#e.byteLength}get readPointer(){return this.#t}set readPointer(e){e<0||e>this.bitLength||(this.#t=e)}get lastReadSize(){return this.#n}set lastReadSize(e){e<0||e>32||(this.#n=e)}get writePointer(){return this.#s}set writePointer(e){e<0||e>this.bitLength||(this.#s=e)}get lastWriteSize(){return this.#r}set lastWriteSize(e){e<0||e>32||(this.#r=e)}static from(t){if(!t.match(/^[A-Za-z0-9\-_]*$/))throw new e({name:"BitBufferError",message:"Encoded string is not url-safe base 64 encoded","encoded-string":t});const n=new a({size:Math.ceil(3*t.length/4)}),s=/[A-Za-z0-9\-_]{1,4}/g;for(const e of t.match(s)||[]){const t=a.#f(e.padEnd(4,"A"));n.write(t,{size:24})}return n.writePointer=0,n.readPointer=0,n}static#f(e){let t=0;for(const[n,s]of e.split("").entries()){t=(t|a.#u.indexOf(s)<<18-6*n)>>>0}return t}static#c(e){let t="";for(let n=0;n<4;n++){const s=e>>>18-6*n<<26>>>26;t+=a.#u[s]}return t}static#a(e){return Math.abs(e).toString(2).length}static get#u(){return"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"}}const o=(...e)=>t=>e.reduce(((e,t)=>t(e)),t),i=(e,t)=>{const n=t.index,s=e.adjacentIndexes.optional.indexOf(n),r=e.adjacentIndexes.all.indexOf(n);if(-1===s||-1===r)return e;const a=[...e.adjacentIndexes.all];a.splice(r,1);const o=[...e.adjacentIndexes.optional];o.splice(s,1);const i={...e.adjacentIndexes.type},l=t.type.toLowerCase();i[l]=[...i[l]],i[l].splice(i[l].indexOf(n),1);const d={...e.adjacentIndexes,all:a,optional:o,type:i};return{...e,adjacentIndexes:d}},l=(e,t)=>{const n=t.index;if(e.adjacentIndexes.all.includes(n))return e;const s=[...e.adjacentIndexes.all,n],r=[...e.adjacentIndexes.optional,n],a={...e.adjacentIndexes.type},o=t.type.toLowerCase();a[o]=[...a[o],n];const i={...e.adjacentIndexes,all:s,optional:r,type:a};return{...e,adjacentIndexes:i}},d=(e,t)=>{const n=t.index,s=e.adjacentIndexes.optional.indexOf(n);if(-1===s)return e;const r=[...e.adjacentIndexes.required];r.push(n);const a=[...e.adjacentIndexes.optional];a.splice(s,1);const o={...e.adjacentIndexes,required:r,optional:a};return{...e,adjacentIndexes:o}},c=e=>[-6,-5,-1,1,5,6].flatMap((t=>{const n=e+t,s=Math.abs(n%6-e%6);return n>35||n<0||s>1?[]:[n]})),p=e=>Math.floor(e/6),f=e=>e%6,u=e=>{const t=p(e),n=f(e);return 2*Math.floor(t/2)+Math.floor(n/3)},h=(e,t)=>{if(!t.adjacencyIDs.optional.has(e.id))return t;const n=new Set(t.adjacencyIDs.optional),s=new Set(t.adjacencyIDs.deleted);n.delete(e.id),s.add(e.id);const r={...t.adjacencyIDs,optional:n,deleted:s},a=[...t.cells],o=a[e.upperIndex],l=a[e.lowerIndex];return a[e.upperIndex]=i(o,l),a[e.lowerIndex]=i(l,o),{...t,cells:a,adjacencyIDs:r}},g=(e,t)=>{if(!t.adjacencyIDs.deleted.has(e.id))return t;const n=new Set(t.adjacencyIDs.optional),s=new Set(t.adjacencyIDs.deleted);n.add(e.id),s.delete(e.id);const r={...t.adjacencyIDs,optional:n,deleted:s},a=[...t.cells],o=a[e.upperIndex],i=a[e.lowerIndex];return a[e.upperIndex]=l(o,i),a[e.lowerIndex]=l(i,o),{...t,cells:a,adjacencyIDs:r}},x=(e,t)=>{if(!t.adjacencyIDs.optional.has(e.id))return t;const n=new Set(t.adjacencyIDs.optional),s=new Set(t.adjacencyIDs.required);n.delete(e.id),s.add(e.id);const r={...t.adjacencyIDs,required:s,optional:n},a=[...t.cells],o=a[e.upperIndex],i=a[e.lowerIndex];return a[e.upperIndex]=d(o,i),a[e.lowerIndex]=d(i,o),{...t,cells:a,adjacencyIDs:r}},y=(...e)=>{let t,n,s;if(e.length>1){n=Math.min(...e),t=Math.max(...e);const r=p(n),[a,o]=[f(n),f(t)];s=16*r+6*a-5*o+5}else{s=e[0];const r=s%16,a=Math.floor(s/16),o=r%5+5*(r%5?0:1)*Math.floor(r/10);n=6*a+o,t=n+[1,6,5][1+o-(1+(16*a+6*o-s)/5)]}const r=n.toString().padStart(2,"0")+t.toString().padStart(2,"0");return{upperIndex:t,lowerIndex:n,id:s,string:r}},w={detective:"detective",worker:"worker",imposter:"imposter",vacant:"vacant"},v=(e,t)=>(e={...e,type:t},t===w.detective?m(e):e),m=e=>{const t=[...e.adjacentIndexes.type.vacant],n=e.adjacentIndexes.type.imposter.length,s={...e.adjacentIndexes.type,imposter:[...e.adjacentIndexes.type.imposter,...t.splice(0,e.value-n)],vacant:t},r={...e.adjacentIndexes,type:s};return{...e,adjacentIndexes:r}},I=(e,t,n=null,s=!1)=>{if(n??=e.typeIndexes[t][0],!n&&0!==n)return[n];const r=new Set([n]);for(const n of r.values()){const a=e.cells[n],o=s?[...a.adjacentIndexes.all]:[...a.adjacentIndexes.type[t]];for(const n of a.adjacentIndexes.type.vacant){const s=e.cells[n],r=new Set;for(const e of s.candidates)r.add(e.type);const a=()=>t===w.worker,i=()=>1===r.size;r.has(t)&&(a()||i())&&o.push(n)}for(const e of o)r.add(e)}return[...r.values()]},b=(e,t)=>{let n=new Set(e.typeIndexes[t].map((e=>e)));if(!n.size&&t===w.worker){n=new Set;for(const s of e.typeIndexes.vacant){e.cells[s].candidates.map((e=>e.type)).includes(t)&&n.add(s)}}const s=[];for(;n.size;){const r=n.values().next().value,a=I(e,t,r);for(const e of a)n.delete(e);s.push(a)}return s},j=(e,t)=>{const n=[];(t={...t,cells:[...t.cells]}).cells[e.index]=e,t=P(e,t);for(const s of e.adjacentIndexes.all){let r=t.cells[s];t.isGenerating&&r.type===w.detective&&e.type===w.imposter&&!r.adjacentIndexes.type.imposter.includes(e.index)&&n.push(r.index),r=z(e,r),t.cells[s]=r}for(const s of n){const n=t.cells[s],r=y(e.index,n.index);e=(t=h(r,t)).cells[e.index]}if(t.isGenerating&&e.type===w.detective){let n=[...e.adjacentIndexes.type.imposter];for(const e of n){const n=t.cells[e];if(n.type===w.vacant){const e=v(n,w.imposter);t=j(e,t)}}for(n=n.sort(((e,n)=>{const s=t.cells[e].adjacentIndexes.all.length,r=t.cells[n].adjacentIndexes.all.length;return s>r?1:s<r?-1:t.random.shuffleArray([1,-1])[0]}));e.value<n.length;){const s=n[0],r=y(e.index,s);n=(e=(t=h(r,t)).cells[e.index]).adjacentIndexes.type.imposter}}if(!t.isGenerating){if(e.type===w.detective){const n=[...e.adjacentIndexes.all];for(const e of n){let n=t.cells[e];const s=n.candidates.filter((e=>e.type!==w.detective));n={...n,candidates:s},t.cells[e]=n}}6===t.typeIndexes.detective.length?t=S(t,w.detective):12===t.typeIndexes.worker.length?t=S(t,w.worker):18===t.typeIndexes.imposter.length&&(t=S(t,w.imposter))}return t},S=(e,t)=>{e={...e,cells:[...e.cells]};for(let n of e.cells){const s=n.candidates.filter((e=>e.type!==t));n={...n,candidates:s},e.cells[n.index]=n}return e},z=(e,t)=>{const n={...t.adjacentIndexes,type:$(e,t)};return{...t,adjacentIndexes:n}},P=(e,t)=>({...t,typeIndexes:$(e,t)}),$=(e,t)=>{const n={detective:[...(t=t.typeIndexes||t.adjacentIndexes.type).detective],worker:[...t.worker],imposter:[...t.imposter],vacant:[...t.vacant]},s=n.vacant.indexOf(e.index);return-1!==s&&(n.vacant.splice(s,1),n[e.type.toLowerCase()].push(e.index)),n},A=e=>{e=o(R,L,M)(e);for(const t of e.typeIndexes.detective){const n=e.cells[t];for(const s of n.adjacentIndexes.type.imposter){const n=y(t,s);e=x(n,e)}}return e},R=e=>{const t=e.random.shuffledIndexArray(36),n=Array(6).fill(6);for(;n.reduce(((e,t)=>e+t),0)>18;)n.unshift(e.random.prng(1,6)),n.pop();for(let s=0;6!==e.typeIndexes.detective.length&&s<36;s++){const r=t[s],a=e.cells[r];if(k(a,n)){const t=v(a,w.detective);e=j(t,e),n.splice(n.indexOf(a.value),1)}}return e},k=(e,t)=>{const n=e.adjacentIndexes.type,s=e.value-n.imposter.length,r=e.value+(e.adjacentIndexes.all.length-2);return e.type===w.vacant&&!n.detective.length&&s<=n.vacant.length&&r>=n.imposter.length&&t.includes(e.value)},L=e=>{const t=e.random.shuffledIndexArray(36);let n;for(let s=0;!n&&s<36;s++){const r=t[s],a=e.cells[r],o=E(a,e);if(o.valid){({continuosIndexes:n}=o);break}}if(n)for(const t of n.splice(0,12)){const n=e.cells[t],s=v(n,w.worker);e=j(s,e)}return e},E=(e,t)=>{const n=I(t,w.vacant,e.index);return{valid:e.type===w.vacant&&n.length>=12,continuosIndexes:n}},M=e=>{for(const t of e.typeIndexes.vacant){const n=e.cells[t];if(n.type===w.vacant){const t=v(n,w.imposter);e=j(t,e)}}return e},C=e=>{for(const t of e.cells)if(t.type===w.imposter){if(new Set(t.adjacentIndexes.all.map((t=>e.cells[t].value))).size<2)return!1}return 0===e.typeIndexes.vacant.length&&6===e.typeIndexes.detective.length&&12===e.typeIndexes.worker.length&&18===e.typeIndexes.imposter.length},G=e=>{for(let t=0;t<36;t++){const n=e.cells[t];if(!n.value&&!n.candidates.length)return!1}return D(e)&&q(e)&&T(e)},D=e=>{const t=b(e,w.detective);if(Math.max(...t.map((e=>e.length)))>1)return!1;for(const t of e.typeIndexes.detective){const n=e.cells[t];let s=n.adjacentIndexes.type.imposter.length,r=n.adjacentIndexes.type.imposter.length;for(const t of n.adjacentIndexes.type.vacant){const n=e.cells[t],a=new Set;for(const e of n.candidates)a.add(e.type);a.has(w.imposter)&&(1===a.size&&s++,r++)}if(n.value<s||n.value>r)return!1}return e.typeIndexes.detective.length<=6&&W(e,w.detective)>=6},q=e=>{const t=b(e,w.worker);return!(Math.max(...t.map((e=>e.length)))<12)&&(e.typeIndexes.worker.length<=12&&W(e,w.worker)>=6)},T=e=>{const t=b(e,w.imposter);if(Math.max(...t.map((e=>e.length)))>=7)return!1;for(const t of e.typeIndexes.imposter){const n=e.cells[t],s=n.hints.imposter.filter((e=>e!==n.value)),r=new Set;for(const t of n.adjacentIndexes.all){const n=e.cells[t],s=n.value?[n.value]:n.candidates.map((e=>e.value));for(const e of s)r.add(e)}if(!r.has(s[0])||!r.has(s[1]))return!1}return e.typeIndexes.imposter.length<=18&&W(e,w.imposter)>=6},W=(e,t)=>{let n=0;for(const s of e.cells)if(s.type===t)n++;else if(s.type===w.vacant){s.candidates.map((e=>e.type)).includes(t)&&n++}return n},B=(e,t)=>{const n=t.shuffleArray(c(e));return{index:e,row:p(e),column:f(e),box:u(e),candidates:t.shuffledIndexArray(6,!0).map((e=>({value:e,type:w.vacant}))),value:0,type:w.vacant,hints:{detective:[],worker:[],imposter:[]},adjacentIndexes:{all:n,required:[],optional:n,type:{detective:[],worker:[],imposter:[],vacant:n}}}},N=(e,t)=>{let n=e.cells[t];const s=e.random.shuffledIndexArray(6,!0),r=[];if(n.type===w.imposter){const t=new Set;for(const s of n.adjacentIndexes.all){const n=e.cells[s];t.add(n.value)}const a=e.random.shuffleArray([...t.values()]).splice(0,2);for(let e=0;e<6;e++){const t=s[e];t===n.value||a.includes(t)||r.push(t)}r.push(...a)}else for(let e=0;e<6;e++){const t=s[e];t!==n.value&&r.push(t)}const a=n.type===w.detective?0:n.type===w.worker?e.random.prng(1,2):e.random.prng(3,5);r.splice(a,0,n.value);const o=r.splice(0,1),i=r.splice(0,2).sort(),l=r.splice(0,3).sort();return n={...n,hints:{detective:o,worker:i,imposter:l}},n},V=e=>{e={...e,cells:[...e.cells]};for(let t=0;t<36;t++){const n=N(e,t);if(e.cells[t]=n,n.type===w.imposter){const t=new Set(n.hints.imposter.filter((e=>e!==n.value)));for(const s of n.adjacentIndexes.required){const n=e.cells[s];t.delete(n.value)}for(const s of n.adjacentIndexes.all){const r=e.cells[s];if(t.has(r.value)){const a=y(n.index,s);e=x(a,e),t.delete(r.value)}}}}return e},O=(e,t=!1)=>{const n=Array.from({length:6},((t,n)=>{const s=n+1;return{value:s,type:e.hints.detective.includes(s)?w.detective:e.hints.worker.includes(s)?w.worker:w.imposter}})),s=w.vacant,r={detective:[],worker:[],imposter:[],vacant:[...e.adjacentIndexes.all]},a={...e.adjacentIndexes,type:r};return t?{...e,candidates:n,value:0,type:s,adjacentIndexes:a}:{...e,candidates:n}},U=(e,t=!1)=>{const n={detective:[],worker:[],imposter:[],vacant:Array.from({length:36},((e,t)=>t))};e=t?{...e,typeIndexes:n,isGenerating:!1,cells:[...e.cells]}:{...e,isGenerating:!1,cells:[...e.cells]};for(const n of e.cells)e.cells[n.index]=O(n,t);return e},_=e=>U(e,!1),H=e=>U(e,!0),Z=e=>{const t=[...e.candidates],n=t.pop(),s=n?.value,r=n?.type;return{...e,value:s,type:r,candidates:t}},Q=e=>Array.from({length:e.candidates.length},(()=>e=Z(e))),Y=(e,t)=>{const{row:n,column:s,box:r,value:a}=e;(t={...t,cells:[...t.cells]}).cells[e.index]=e;const o=[...F(n),...J(s),...K(r)];for(const e of o){let n=t.cells[e];const s=n.candidates.filter((e=>e.value!==a));n={...n,candidates:s},t.cells[e]=n}if(!t.isGenerating)for(const n of e.adjacentIndexes.all){let e=t.cells[n];const s=e.candidates.filter((e=>e.value!==a));e={...e,candidates:s},t.cells[n]=e}return t},F=e=>{const t=Array(6);for(let n=0;n<6;n++)t[n]=6*e+n;return t},J=e=>{const t=Array(6);for(let n=0;n<6;n++)t[n]=6*n+e;return t},K=e=>{const t=Array(6);for(let n=0;n<6;n++){const s=e%2,r=Math.floor(e/2),a=n%3,o=Math.floor(n/3);t[n]=3*s+12*r+a+6*o}return t},X=e=>{const t=new Set;for(let n=0;n<36;n++){const s=e.cells[n],r=s.value?[s.value]:s.candidates.map((e=>e.value));if(!r)return!1;for(let e=0;e<r.length;e++){const n=6*s.row+r[e],a=36+6*s.column+r[e],o=72+6*s.box+r[e];t.add(n).add(a).add(o)}}return 108===t.size},ee=e=>{const t=[e];let n=0;const s=e.random.shuffledIndexArray(36);for(let r=0;r<36;r++){const a=s[r],o=Z(e.cells[a]);if(e=Y(o,e),X(e))t.push(e);else{let n=e.cells[a];for(;!n.candidates.length;)n=(e=t.pop()).cells[s[--r]];n.value=0,(e=t.slice(-1)[0]).cells[n.index]=n,--r}if(++n>1e4)return ee(t[0])}return e},te=(e,t)=>{const n=e.cells[t],s=Q(n),r=[];for(const t of s){let n=Y(t,e);X(n)&&(n=j(t,n),G(n)&&r.push(n))}return r},ne=e=>{let t=0,n=[e];for(let e=0;e<36;e++){t+=n.length;const e=[];for(const t of n){const n=[...t.typeIndexes.vacant].sort(((e,n)=>{const s=t.cells[e].candidates.length,r=t.cells[n].candidates.length;return s>r?1:s<r?-1:t.random.shuffleArray([1,-1])[0]}));e.push(...te(t,n[0]))}n=e}return{grids:n,rawEntropy:t}},se=e=>{const t=(e=o(re,ae)(e)).random.iterate();for(const n of e.adjacencyIDs.optional){const s=y(n);e=e.random.iterate()>t?x(s,e):h(s,e)}return e},re=e=>{const t=[];for(const n of e.typeIndexes.imposter){const s=e.cells[n];for(const r of s.adjacentIndexes.optional){const s=y(n,r),a=h(s,e);oe(a)?(e=a,t.push(s)):e=x(s,e)}}for(const n of t){const t=g(n,e);G(t)&&(e=t)}return e},ae=e=>{const t=[];for(const n of e.typeIndexes.worker){const s=e.cells[n],r=s.adjacentIndexes.type.worker.filter((e=>s.adjacentIndexes.optional.includes(e)));for(const s of r){const r=y(n,s),a=h(r,e);oe(a)?(e=a,t.push(r)):e=x(r,e)}}for(const n of t)e=g(n,e);return e},oe=e=>{for(const t of e.cells)if(t.type===w.imposter){if(new Set(t.adjacentIndexes.all.map((t=>e.cells[t].value))).size<2)return!1}return 36===I(e,w.vacant,0,!0).length},ie=e=>{let t=e;for(const n of e.cells)for(const s of n.adjacentIndexes.all){if(e.cells[s].value===n.value){const e=y(s,n.index);t=h(e,t)}}return t},le=e=>{const t=Array.from({length:36},((t,n)=>B(n,e))),n={detective:[],worker:[],imposter:[],vacant:e.shuffledIndexArray(36)},s=new Set;t.forEach((e=>{e.adjacentIndexes.all.forEach((t=>{const n=y(e.index,t);s.add(n.id)}))}));return{cells:t,typeIndexes:n,adjacencyIDs:{required:new Set,optional:s,deleted:new Set},random:e,isGenerating:!0}},de=e=>{let t,n;do{t=o(le,ee,ie)(e);do{n=A(t)}while(!C(n));t=o(se,V)(n)}while(!G(t));const s=o(H,ne)(t),{rawEntropy:r}=s;return 1===s.grids.length&&ce(t,s.grids[0])?(t=_(t),{grid:t,rawEntropy:r}):de(e)},ce=(e,t)=>!0,pe=(e,t)=>{const n=[];for(let s=0;s<6;s++){const r=6*t+s,a=e.cells[r],[o]=a.hints.detective,i=[o===a.value?"(":" ",o===a.value?")":" "];let l=`${a.type===w.vacant?"V  ":""}${i[0]}${o||0}${i[1]}`.padStart(7);l=l.padEnd(11);const d=s?"":"  ";n.push(`${d}┌${l}┐  `)}console.log(n.join(""))},fe=(e,t)=>{const n=[];for(let s=0;s<6;s++){const r=6*t+s,a=e.cells[r],[o,i]=a.hints.worker,l=[o===a.value?"(":" ",o===a.value?")":" ",i===a.value?"(":" ",i===a.value?")":" "],d=`${l[0]}${o||0}${l[1]}`,c=`${l[2]}${i||0}${l[3]}`;let p=d.padStart(5);p+=` ${c}`,p=p.padEnd(11);const f=a.adjacentIndexes.all.includes(r+1)?"──":"  ",u=s?"":"  ";n.push(`${u}│${p}│${f}`)}console.log(n.join(""))},ue=(e,t)=>{const n=[];for(let s=0;s<6;s++){const r=6*t+s,a=e.cells[r],[o,i,l]=a.hints.imposter,d=[o===a.value?"(":" ",o===a.value?")":" ",i===a.value?"(":" ",i===a.value?")":" ",l===a.value?"(":" ",l===a.value?")":" "],c=`${d[0]}${o||0}${d[1]}`,p=`${d[2]}${i||0}${d[3]}`,f=`${d[4]}${l||0}${d[5]}`;let u=c.padStart(3);u+=` ${p} ${f}`,u=u.padEnd(11);const h=s?"":"  ";n.push(`${h}└${u}┘  `)}console.log(n.join(""))},he=(e,t)=>{const n=[];for(let s=0;s<6;s++){const r=6*t+s,a=e.cells[r],o=a.adjacentIndexes.all.includes(r+5),i=a.adjacentIndexes.all.includes(r+6);let l=o?" ╱":"  ";l=l.padEnd(8),l+=i?"│":" ";const d=l.padEnd(15);n.push(`${d}`)}console.log(n.join("")),n.forEach(((e,t)=>{n[t]=`${e[1]} ${e.slice(2)}`})),console.log(n.join(""))},ge=e=>{const t=new a({size:11});for(let n=0;n<84;n++){const s=e.adjacencyIDs.required.has(n);t.write(s?1:0)}return t},xe=e=>{let t=new a({size:3});const{value:n,hints:s}=e,r=[n,...s.detective,...s.worker];for(const e of r)t.write(e);if(6!==e.candidates.length){t.write(1);const n=O(e).candidates;for(let t=0;t<6;t++)e.candidates.includes(n[t])}else t.write(0);const o=Math.ceil(t.writePointer/8);return t=t.copy({target:new a({size:o}),sourceEnd:t.writePointer}),t},ye=e=>{let t=new a({size:128});for(const n of e.cells){const e=xe(n);e.copy({target:t,sourceEnd:e.writePointer})}const n=ge(e);n.copy({target:t,sourceEnd:n.writePointer});const s=Math.ceil(t.writePointer/8);return t=t.copy({target:new a({size:s})}),t};exports.CELL_TYPES=w,exports.addCellAdjacency=l,exports.addGridAdjacency=g,exports.allContinuosTypeIndexes=b,exports.completedGridTypes=C,exports.continuosTypeIndexes=I,exports.deserializeCell=(e,t)=>{const n=c(e);return{index:e,row:p(e),column:f(e),box:u(e),candidates:[],value:0,type:w.vacant,hints:{detective:[],worker:[],imposter:[]},adjacentIndexes:{all:n,required:[],optional:n,type:{detective:[],worker:[],imposter:[],vacant:n}}}},exports.deserializeGrid=()=>{},exports.deserializeImpostori=e=>{a.from(e)},exports.fillCellHints=N,exports.fillCellType=v,exports.fillCellValue=Z,exports.fillGridHints=V,exports.fillGridTypes=A,exports.fillGridValues=ee,exports.forkCellValue=Q,exports.generateEmptyCell=B,exports.generateEmptyGrid=le,exports.generateGrid=de,exports.generateImpostori=e=>{const t=new r(e),{grid:n,rawEntropy:s}=de(t);return{grid:n,seed:t.config.seed,version:"1.0.0",rawEntropy:s,correctedEntropy:0,rating:0,grade:"",serializedString:""}},exports.getAdjacencyData=y,exports.getAdjacentIndexes=c,exports.getBox=u,exports.getColumn=f,exports.getRow=p,exports.hardResetCell=e=>O(e,!0),exports.hardResetGrid=H,exports.printGrid=e=>{for(let t=0;t<6;t++)pe(e,t),fe(e,t),ue(e,t),he(e,t)},exports.propagateCellType=j,exports.propagateCellValue=Y,exports.pruneGridAdjacencies=se,exports.removeCellAdjacency=i,exports.removeGridAdjacency=h,exports.removeTwins=ie,exports.requireCellAdjacency=d,exports.requireGridAdjacency=x,exports.resetCell=O,exports.resetGrid=U,exports.serializeAdjacencies=ge,exports.serializeCell=xe,exports.serializeGrid=ye,exports.serializeImpostori=async e=>{let t=new a({size:128});t.write(e.seed),t.write(e.rawEntropy);ye(e.grid).copy({target:t,targetStart:t.writePointer});const n=Math.ceil(t.writePointer/8);t=t.copy({target:new a({size:n})}),console.log(e),console.log(await t.toString())},exports.softResetCell=e=>O(e,!1),exports.softResetGrid=_,exports.solveCell=te,exports.solveGrid=ne,exports.validateGridTypes=G,exports.validateGridValues=X;
