"use strict";require("process"),require("readline");var e=require("fs"),t=require("path"),r=require("url"),n="undefined"!=typeof document?document.currentScript:null;class s extends Error{constructor(e){super();let t="";for(const r in e)switch(r){case"name":this.name=e[r];break;case"message":t=`${e[r]}\n${t}`;break;default:{const n=`${r}: ${e[r]}`;t=`${t}${o(n,"gray",1)}\n`}}this.message=t||""}}const a=(e,{modifiers:t=[],tabs:r=0,tabSize:n=4}={})=>{let s="";for(const e of t)s=`${s}${e}`;const a=i.decorations.reset;return`${s}${" ".repeat(r*n)}${e}${a}`},o=(e,t,r=0)=>{const n=i.fgColors[t];return a(e,n?{modifiers:[n],tabs:r}:{tabs:r})},i={fgColors:{black:"[30m",red:"[31m",green:"[32m",yellow:"[33m",blue:"[34m",magenta:"[35m",cyan:"[36m",white:"[37m",gray:"[90m"},bgColors:{black:"[40m",red:"[41m",green:"[42m",yellow:"[43m",blue:"[44m",magenta:"[45m",cyan:"[46m",white:"[47m",gray:"[100m"},decorations:{reset:"[0m",bright:"[1m",dim:"[2m",underline:"[4m",blink:"[5m",reverse:"[7m",hidden:"[8m"}},d="",l="worker",c="imposter",p="vacant",u=({upper:e=1/0,lower:t=-1/0,mean:r=0,stdDev:n=1,precision:s=5,mode:a=l}={})=>{switch(e=(e-r)/n,t=(t-r)/n,s=Math.min(Math.max(s,1),100),a){case c:const r=u({upper:e,precision:s+1}),n=u({upper:t,precision:s+1});return parseFloat((r-n).toPrecision(s));case p:const a=1-u({upper:e,lower:t,mode:c,precision:s});return parseFloat(a.toPrecision(s));case d:const o=1-u({upper:t,precision:s});return parseFloat(o.toPrecision(s));default:if(e===1/0)return 1;if(e===-1/0)return 0;let[i,l]=[0,1],[f,h]=[0,0];for(;i.toPrecision(s)!==l.toPrecision(s);){let t=1;for(let e=0;e<h;e++)t*=e+1;f+=(-1)**h*e**(2*h+1)/((2*h+1)*2**h*t),i=l,l=.5+1/Math.sqrt(2*Math.PI)*f,h++}return parseFloat(l.toPrecision(s))}};class f{constructor(e=f.seed(),t=34319,r=89459){e%t!=0&&e%r!=0||e++,this.config={seed:e,primeP:t,primeQ:r,divisor:t*r},this.state={iteration:0,iteratedSeed:e}}iterate(){return this.state.iteration++,this.state.iteratedSeed=this.state.iteratedSeed**2%this.config.divisor,this.state.iteratedSeed/this.config.divisor}prng(e=0,t=1){return f.floatToRangedInteger(this.iterate(),e,t)}shuffleArray([...e]){return Array.from({length:e.length},(()=>e.splice(this.prng(0,e.length-1),1)[0]))}shuffledIndexArray(e,t=!1){return this.shuffleArray(Array.from({length:e},((e,r)=>r+t)))}static seed(){return f.floatToRangedInteger(Math.random(),2**31,2**32-1)}static floatToRangedInteger(e,t,r){return Math.round(t+e*(r-t))}}class h{#e;#t;#r;#n;#s;constructor({length:e=16,size:t=Math.floor(6*e/8),buffer:r=new ArrayBuffer(t)}={}){this.#e=r,this.#t=0,this.#r=0,this.#n=0,this.#s=0}write(e,{size:t=h.#a(e),offset:r=this.#n,signed:n=!1}={}){return this.#o().append(e,{size:t,offset:r,signed:n}).isWriteable?this.#i(e,{size:t,offset:r,signed:n}):NaN}writeAbsolute(e,{offset:t=this.#n,signed:r=!1}={}){const n={value:h.#a(e)-1,size:5};if(!this.#o().append(n.value,{...n,offset:t}).append(e,{signed:r}).isWriteable)return NaN;this.#i(n.value,{...n,offset:t});return this.#i(e,{signed:r})}writeRelative(e,{offset:t=this.#n,signed:r=!1}={}){0===e&&(e=1);const n=h.#a(e)-this.#s,s={value:n>0?1<<n>>>0:0,size:Math.abs(n)+1};if(!this.#o().append(s.value,{...s,offset:t}).append(e,{signed:r}).isWriteable)return NaN;this.#i(s.value,{...s,offset:t});return this.#i(e,{signed:r})}writeString(e,{offset:t=this.#n}={}){const r={value:h.#a(e.length),size:5};let n=this.#o().append(r.value,{...r}).append(e.length);for(let t=0;t<e.length;t++)n=n.append(0,{size:8});if(!n.isWriteable)return"";this.#i(r.value,{...r,offset:t}),this.#i(e.length);for(const t of e)this.#i(t.charCodeAt(0),{size:8});return e}read(e,{offset:t=this.#t,signed:r=!1}={}){return this.#d().append(e,{offset:t,signed:r}).isReadable?this.#l(e,{offset:t,signed:r}):NaN}readAbsolute({offset:e=this.#t,signed:t=!1}={}){const r=this.#t,n=this.#r,s=this.#d().append(5,{offset:e});let a=0;return s.isReadable&&(a=this.#l(5,{offset:e})+1,s.append(a,{signed:t})),s.isReadable&&a?this.#l(a,{signed:t}):(this.#t=r,this.#r=n,NaN)}readRelative({offset:e=this.#t,signed:t=!1}={}){const r=this.#t,n=this.#r;let s=1;const a=this.#d().append(1,{offset:e});a.isReadable&&(s=this.#l(1,{offset:e})?1:-1);let o=0;for(;a.append(1).isReadable&&!this.#l(1);)o++;const i=n+s*o;return a.append(i,{signed:t}),a.isReadable&&i?(this.#t--,this.#l(i,{signed:t})):(this.#t=r,this.#r=n,NaN)}readString({offset:e=this.#t}={}){const t=this.#t,r=this.#r,n=this.#d().append(5,{offset:e});let s=0;n.isReadable&&(s=this.#l(5,{offset:e})),n.append(s);let a=0;if(n.isReadable&&(a=this.#l(s)),!n.isReadable||!a)return this.#t=t,this.#r=r,"";let o="";for(let e=0;e<a;e++){if(n.append(8),!n.isReadable)return this.#t=t,this.#r=r,"";o+=String.fromCharCode(this.#l(8))}return o}copy({target:e,targetStart:t=e?.writePointer||0,sourceStart:r=0,sourceEnd:n=this.bitLength}={}){if(r<0||n>this.bitLength)throw new s({name:"BitBufferError",message:"Requested bits out of source buffer range","source-start":r,"source-end":n,"source-bit-length":this.bitLength});const a=n-r,o=Math.ceil((a+t)/8);e??=new h({size:o});const i=e.bitLength-t;if(a>i)throw new s({name:"BitBufferError",message:"Source bits exceed bits available in target buffer","source-bits":a,"target-bits":i});for(let n=0;n<a;n++)e.write(this.#l(1,{offset:r+n}),{size:1,offset:t+n});return e}toString(){let e="",t=0,r=0;const n=new Uint8Array(this.#e);for(let s=0;s<3*Math.ceil(this.byteLength/3);s++){r=(r|(n[s]||0)<<16-8*t)>>>0,t=++t%3,t||(e+=h.#c(r),r=0)}return e}#o(){const e={writeable:!0,offset:this.#n},t=(r,{size:n=h.#a(r),offset:s=e.offset,signed:a=!1}={})=>{if(e.writeable){const t=Math.abs(r),o=this.bitLength-s;e.writeable=!(!a&&r<0)&&(!(h.#a(t)>n)&&(!!Number.isInteger(t)&&(!(n<0||n>32)&&!(n+(a?1:0)>o))))}return e.offset+=n,{append:t,get isWriteable(){return e.writeable}}};return{append:t,get isWriteable(){return e.writeable}}}#i(e,{size:t=h.#a(e),offset:r=this.#n,signed:n=!1}={}){const s=Math.abs(e),{view:a,byteLength:o,subBit:i}=this.#p(t,r);for(let e=0;e<o;e++){const r=a.getUint8(e);let n=0;for(let a=0;a<8;a++){const o=8*e+a;n|=(o<i||o>i+t?r<<24+a>>>31:s<<32-t+(o-i)>>>31)<<7-a}a.setUint8(e,n)}return this.#n=r+t,n&&this.#i(e>=0?1:0,{size:1}),this.#s=t,e}#d(){const e={readable:!0,offset:this.#t},t=(r,{offset:n=e.offset,signed:s=!1}={})=>{if(e.readable){const t=this.bitLength-n;e.readable=!(r<0||r>32)&&!(r+(s?1:0)>t)}return e.offset+=r,{append:t,get isReadable(){return e.readable}}};return{append:t,get isReadable(){return e.readable}}}#l(e,{offset:t=this.#t,signed:r=!1}={}){const{view:n,byteLength:s,subBit:a}=this.#p(e,t);let o=0;for(let e=0;e<s;e++){const t=24+a-8*e;o=t>=0?(o|n.getUint8(e)<<t)>>>0:(o|n.getUint8(e)>>>-t)>>>0}this.#t=t+e;const i=r&&0===this.#l(1)?-1:1;return this.#r=e,i*(o>>>32-e)}#p(e,t){const r=Math.floor(t/8),n=t-8*r,s=Math.ceil((n+e)/8);this.byteLength;return{view:new DataView(this.#e,r,s),byteLength:s,subBit:n}}get bitLength(){return this.byteLength<<3}get byteLength(){return this.#e.byteLength}get readPointer(){return this.#t}set readPointer(e){e<0||e>this.bitLength||(this.#t=e)}get lastReadSize(){return this.#r}set lastReadSize(e){e<0||e>32||(this.#r=e)}get writePointer(){return this.#n}set writePointer(e){e<0||e>this.bitLength||(this.#n=e)}get lastWriteSize(){return this.#s}set lastWriteSize(e){e<0||e>32||(this.#s=e)}static from(e){if(!e.match(/^[A-Za-z0-9\-_]*$/))throw new s({name:"BitBufferError",message:"Encoded string is not url-safe base 64 encoded","encoded-string":e});const t=new h({size:Math.ceil(3*e.length/4)}),r=/[A-Za-z0-9\-_]{1,4}/g;for(const n of e.match(r)||[]){const e=h.#u(n.padEnd(4,"A"));t.write(e,{size:24})}return t.writePointer=0,t.readPointer=0,t}static#u(e){let t=0;for(const[r,n]of e.split("").entries()){t=(t|h.#f.indexOf(n)<<18-6*r)>>>0}return t}static#c(e){let t="";for(let r=0;r<4;r++){const n=e>>>18-6*r<<26>>>26;t+=h.#f[n]}return t}static#a(e){return Math.abs(e).toString(2).length}static get#f(){return"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"}}const g=(...e)=>t=>e.reduce(((e,t)=>t(e)),t);class x{constructor(e){this.url=e}absolutePath(e){return t.join(this.__dirname,e)}relativePath(e){return t.relative(this.__dirname,e)}get __pathname(){return r.fileURLToPath(this.url)}get __dirname(){return t.dirname(this.__pathname)}get __filename(){return this.__pathname.replace(this.__dirname,"").slice(1)}}const y=(e,t)=>{const r=t.index,n=e.adjacentIndexes.optional.indexOf(r),s=e.adjacentIndexes.all.indexOf(r);if(-1===n||-1===s)return e;const a=[...e.adjacentIndexes.all];a.splice(s,1);const o=[...e.adjacentIndexes.optional];o.splice(n,1);const i={...e.adjacentIndexes.type},d=t.type.toLowerCase();i[d]=[...i[d]],i[d].splice(i[d].indexOf(r),1);const l={...e.adjacentIndexes,all:a,optional:o,type:i};return{...e,adjacentIndexes:l}},w=(e,t)=>{const r=t.index;if(e.adjacentIndexes.all.includes(r))return e;const n=[...e.adjacentIndexes.all,r],s=[...e.adjacentIndexes.optional,r],a={...e.adjacentIndexes.type},o=t.type.toLowerCase();a[o]=[...a[o],r];const i={...e.adjacentIndexes,all:n,optional:s,type:a};return{...e,adjacentIndexes:i}},m=(e,t)=>{const r=t.index,n=e.adjacentIndexes.optional.indexOf(r);if(-1===n)return e;const s=[...e.adjacentIndexes.required];s.push(r);const a=[...e.adjacentIndexes.optional];a.splice(n,1);const o={...e.adjacentIndexes,required:s,optional:a};return{...e,adjacentIndexes:o}},v=e=>[-6,-5,-1,1,5,6].flatMap((t=>{const r=e+t,n=Math.abs(r%6-e%6);return r>35||r<0||n>1?[]:[r]})),I=e=>Math.floor(e/6),b=e=>e%6,j=e=>{const t=I(e),r=b(e);return 2*Math.floor(t/2)+Math.floor(r/3)},S=(e,t)=>{if(!t.adjacencyIDs.optional.has(e.id))return t;const r=new Set(t.adjacencyIDs.optional),n=new Set(t.adjacencyIDs.deleted);r.delete(e.id),n.add(e.id);const s={...t.adjacencyIDs,optional:r,deleted:n},a=[...t.cells],o=a[e.upperIndex],i=a[e.lowerIndex];return a[e.upperIndex]=y(o,i),a[e.lowerIndex]=y(i,o),{...t,cells:a,adjacencyIDs:s}},z=(e,t)=>{if(!t.adjacencyIDs.deleted.has(e.id))return t;const r=new Set(t.adjacencyIDs.optional),n=new Set(t.adjacencyIDs.deleted);r.add(e.id),n.delete(e.id);const s={...t.adjacencyIDs,optional:r,deleted:n},a=[...t.cells],o=a[e.upperIndex],i=a[e.lowerIndex];return a[e.upperIndex]=w(o,i),a[e.lowerIndex]=w(i,o),{...t,cells:a,adjacencyIDs:s}},P=(e,t)=>{if(!t.adjacencyIDs.optional.has(e.id))return t;const r=new Set(t.adjacencyIDs.optional),n=new Set(t.adjacencyIDs.required);r.delete(e.id),n.add(e.id);const s={...t.adjacencyIDs,required:n,optional:r},a=[...t.cells],o=a[e.upperIndex],i=a[e.lowerIndex];return a[e.upperIndex]=m(o,i),a[e.lowerIndex]=m(i,o),{...t,cells:a,adjacencyIDs:s}},k=(...e)=>{let t,r,n;if(e.length>1){r=Math.min(...e),t=Math.max(...e);const s=I(r),[a,o]=[b(r),b(t)];n=16*s+6*a-5*o+5}else{n=e[0];const s=n%16,a=Math.floor(n/16),o=s%5+5*(s%5?0:1)*Math.floor(s/10);r=6*a+o,t=r+[1,6,5][1+o-(1+(16*a+6*o-n)/5)]}const s=r.toString().padStart(2,"0")+t.toString().padStart(2,"0");return{upperIndex:t,lowerIndex:r,id:n,string:s}},E={detective:"detective",worker:"worker",imposter:"imposter",vacant:"vacant"},A=(e,t)=>(e={...e,type:t},t===E.detective?$(e):e),$=e=>{const t=[...e.adjacentIndexes.type.vacant],r=e.adjacentIndexes.type.imposter.length,n={...e.adjacentIndexes.type,imposter:[...e.adjacentIndexes.type.imposter,...t.splice(0,e.value-r)],vacant:t},s={...e.adjacentIndexes,type:n};return{...e,adjacentIndexes:s}},R=(e,t,r=null,n=!1)=>{if(r??=e.typeIndexes[t][0],!r&&0!==r)return[r];const s=new Set([r]);for(const r of s.values()){const a=e.cells[r],o=n?[...a.adjacentIndexes.all]:[...a.adjacentIndexes.type[t]];for(const r of a.adjacentIndexes.type.vacant){const n=e.cells[r],s=new Set;for(const e of n.candidates)s.add(e.type);const a=()=>t===E.worker,i=()=>1===s.size;s.has(t)&&(a()||i())&&o.push(r)}for(const e of o)s.add(e)}return[...s.values()]},M=(e,t)=>{let r=new Set(e.typeIndexes[t].map((e=>e)));if(!r.size&&t===E.worker){r=new Set;for(const n of e.typeIndexes.vacant){e.cells[n].candidates.map((e=>e.type)).includes(t)&&r.add(n)}}const n=[];for(;r.size;){const s=r.values().next().value,a=R(e,t,s);for(const e of a)r.delete(e);n.push(a)}return n},L=(e,t)=>{const r=[];(t={...t,cells:[...t.cells]}).cells[e.index]=e,t=D(e,t);for(const n of e.adjacentIndexes.all){let s=t.cells[n];t.isGenerating&&s.type===E.detective&&e.type===E.imposter&&!s.adjacentIndexes.type.imposter.includes(e.index)&&r.push(s.index),s=C(e,s),t.cells[n]=s}for(const n of r){const r=t.cells[n],s=k(e.index,r.index);e=(t=S(s,t)).cells[e.index]}if(t.isGenerating&&e.type===E.detective){let r=[...e.adjacentIndexes.type.imposter];for(const e of r){const r=t.cells[e];if(r.type===E.vacant){const e=A(r,E.imposter);t=L(e,t)}}for(r=r.sort(((e,r)=>{const n=t.cells[e].adjacentIndexes.all.length,s=t.cells[r].adjacentIndexes.all.length;return n>s?1:n<s?-1:t.random.shuffleArray([1,-1])[0]}));e.value<r.length;){const n=r[0],s=k(e.index,n);r=(e=(t=S(s,t)).cells[e.index]).adjacentIndexes.type.imposter}}if(!t.isGenerating){if(e.type===E.detective){const r=[...e.adjacentIndexes.all];for(const e of r){let r=t.cells[e];const n=r.candidates.filter((e=>e.type!==E.detective));r={...r,candidates:n},t.cells[e]=r}}6===t.typeIndexes.detective.length?t=G(t,E.detective):12===t.typeIndexes.worker.length?t=G(t,E.worker):18===t.typeIndexes.imposter.length&&(t=G(t,E.imposter))}return t},G=(e,t)=>{e={...e,cells:[...e.cells]};for(let r of e.cells){const n=r.candidates.filter((e=>e.type!==t));r={...r,candidates:n},e.cells[r.index]=r}return e},C=(e,t)=>{const r={...t.adjacentIndexes,type:q(e,t)};return{...t,adjacentIndexes:r}},D=(e,t)=>({...t,typeIndexes:q(e,t)}),q=(e,t)=>{const r={detective:[...(t=t.typeIndexes||t.adjacentIndexes.type).detective],worker:[...t.worker],imposter:[...t.imposter],vacant:[...t.vacant]},n=r.vacant.indexOf(e.index);return-1!==n&&(r.vacant.splice(n,1),r[e.type.toLowerCase()].push(e.index)),r},_=e=>{e=g(T,N,W)(e);for(const t of e.typeIndexes.detective){const r=e.cells[t];for(const n of r.adjacentIndexes.type.imposter){const r=k(t,n);e=P(r,e)}}return e},T=e=>{const t=e.random.shuffledIndexArray(36),r=Array(6).fill(6);for(;r.reduce(((e,t)=>e+t),0)>18;)r.unshift(e.random.prng(1,6)),r.pop();for(let n=0;6!==e.typeIndexes.detective.length&&n<36;n++){const s=t[n],a=e.cells[s];if(O(a,r)){const t=A(a,E.detective);e=L(t,e),r.splice(r.indexOf(a.value),1)}}return e},O=(e,t)=>{const r=e.adjacentIndexes.type,n=e.value-r.imposter.length,s=e.value+(e.adjacentIndexes.all.length-2);return e.type===E.vacant&&!r.detective.length&&n<=r.vacant.length&&s>=r.imposter.length&&t.includes(e.value)},N=e=>{const t=e.random.shuffledIndexArray(36);let r;for(let n=0;!r&&n<36;n++){const s=t[n],a=e.cells[s],o=V(a,e);if(o.valid){({continuosIndexes:r}=o);break}}if(r)for(const t of r.splice(0,12)){const r=e.cells[t],n=A(r,E.worker);e=L(n,e)}return e},V=(e,t)=>{const r=R(t,E.vacant,e.index);return{valid:e.type===E.vacant&&r.length>=12,continuosIndexes:r}},W=e=>{for(const t of e.typeIndexes.vacant){const r=e.cells[t];if(r.type===E.vacant){const t=A(r,E.imposter);e=L(t,e)}}return e},B=e=>{for(const t of e.cells)if(t.type===E.imposter){if(new Set(t.adjacentIndexes.all.map((t=>e.cells[t].value))).size<2)return!1}return 0===e.typeIndexes.vacant.length&&6===e.typeIndexes.detective.length&&12===e.typeIndexes.worker.length&&18===e.typeIndexes.imposter.length},U=e=>{for(let t=0;t<36;t++){const r=e.cells[t];if(!r.value&&!r.candidates.length)return!1}return F(e)&&Z(e)&&H(e)},F=e=>{const t=M(e,E.detective);if(Math.max(...t.map((e=>e.length)))>1)return!1;for(const t of e.typeIndexes.detective){const r=e.cells[t];let n=r.adjacentIndexes.type.imposter.length,s=r.adjacentIndexes.type.imposter.length;for(const t of r.adjacentIndexes.type.vacant){const r=e.cells[t],a=new Set;for(const e of r.candidates)a.add(e.type);a.has(E.imposter)&&(1===a.size&&n++,s++)}if(r.value<n||r.value>s)return!1}return e.typeIndexes.detective.length<=6&&J(e,E.detective)>=6},Z=e=>{const t=M(e,E.worker);return!(Math.max(...t.map((e=>e.length)))<12)&&(e.typeIndexes.worker.length<=12&&J(e,E.worker)>=6)},H=e=>{const t=M(e,E.imposter);if(Math.max(...t.map((e=>e.length)))>=7)return!1;for(const t of e.typeIndexes.imposter){const r=e.cells[t],n=r.hints.imposter.filter((e=>e!==r.value)),s=new Set;for(const t of r.adjacentIndexes.all){const r=e.cells[t],n=r.value?[r.value]:r.candidates.map((e=>e.value));for(const e of n)s.add(e)}if(!s.has(n[0])||!s.has(n[1]))return!1}return e.typeIndexes.imposter.length<=18&&J(e,E.imposter)>=6},J=(e,t)=>{let r=0;for(const n of e.cells)if(n.type===t)r++;else if(n.type===E.vacant){n.candidates.map((e=>e.type)).includes(t)&&r++}return r},Q=(e,t)=>{const r=t.shuffleArray(v(e));return{index:e,row:I(e),column:b(e),box:j(e),candidates:t.shuffledIndexArray(6,!0).map((e=>({value:e,type:E.vacant}))),value:0,clientValue:0,type:E.vacant,hints:{detective:[],worker:[],imposter:[]},adjacentIndexes:{all:r,required:[],optional:r,type:{detective:[],worker:[],imposter:[],vacant:r}}}},Y=(e,t)=>{let r=e.cells[t];const n=e.random.shuffledIndexArray(6,!0),s=[];if(r.type===E.imposter){const t=new Set;for(const n of r.adjacentIndexes.all){const r=e.cells[n];t.add(r.value)}const a=e.random.shuffleArray([...t.values()]).splice(0,2);for(let e=0;e<6;e++){const t=n[e];t===r.value||a.includes(t)||s.push(t)}s.push(...a)}else for(let e=0;e<6;e++){const t=n[e];t!==r.value&&s.push(t)}const a=r.type===E.detective?0:r.type===E.worker?e.random.prng(1,2):e.random.prng(3,5);s.splice(a,0,r.value);const o=s.splice(0,1),i=s.splice(0,2).sort(),d=s.splice(0,3).sort();return r={...r,hints:{detective:o,worker:i,imposter:d}},r},K=e=>{e={...e,cells:[...e.cells]};for(let t=0;t<36;t++){const r=Y(e,t);if(e.cells[t]=r,r.type===E.imposter){const t=new Set(r.hints.imposter.filter((e=>e!==r.value)));for(const n of r.adjacentIndexes.required){const r=e.cells[n];t.delete(r.value)}for(const n of r.adjacentIndexes.all){const s=e.cells[n];if(t.has(s.value)){const a=k(r.index,n);e=P(a,e),t.delete(s.value)}}}}return e},X=(e,t=!1)=>{const r=Array.from({length:6},((t,r)=>{const n=r+1;return{value:n,type:e.hints.detective.includes(n)?E.detective:e.hints.worker.includes(n)?E.worker:E.imposter}})),n=E.vacant,s={detective:[],worker:[],imposter:[],vacant:[...e.adjacentIndexes.all]},a={...e.adjacentIndexes,type:s};return t?{...e,candidates:r,value:0,type:n,adjacentIndexes:a}:{...e,candidates:r}},ee=e=>{const t=[...e.candidates.sort(((e,t)=>e.value-t.value))],r={};for(const t of Object.keys(e.hints))r[t]=[...e.hints[t].sort(((e,t)=>e-t))];const n={};for(const t of Object.keys(e.adjacentIndexes))if("type"!==t)n[t]=[...e.adjacentIndexes[t].sort(((e,t)=>e-t))];else{n.type={};for(const t of Object.keys(e.adjacentIndexes.type))n.type[t]=[...e.adjacentIndexes.type[t].sort(((e,t)=>e-t))]}return{...e,candidates:t,hints:r,adjacentIndexes:n}},te=(e,t=!1)=>{const r={detective:[],worker:[],imposter:[],vacant:Array.from({length:36},((e,t)=>t))};e=t?{...e,typeIndexes:r,cells:[...e.cells],isGenerating:!1}:{...e,cells:[...e.cells],isGenerating:!1};for(const r of e.cells)e.cells[r.index]=X(r,t);return e},re=e=>te(e,!1),ne=e=>te(e,!0),se=e=>{const t={};for(const r of Object.keys(e.typeIndexes))t[r]=[...e.typeIndexes[r].sort(((e,t)=>e-t))];const r={required:new Set,optional:new Set,deleted:new Set};for(let t=0;t<85;t++)e.adjacencyIDs.required.has(t)?r.required.add(t):e.adjacencyIDs.optional.has(t)?r.optional.add(t):r.deleted.add(t);e={...e,cells:[...e.cells],typeIndexes:t,adjacencyIDs:r};for(const t of e.cells)e.cells[t.index]=ee(t);return e},ae=e=>{const t=[...e.candidates],r=t.pop(),n=r?.value,s=r?.type;return{...e,value:n,type:s,candidates:t}},oe=e=>Array.from({length:e.candidates.length},(()=>e=ae(e))),ie=(e,t)=>{const{row:r,column:n,box:s,value:a}=e;(t={...t,cells:[...t.cells]}).cells[e.index]=e;const o=[...de(r),...le(n),...ce(s)];for(const e of o){let r=t.cells[e];const n=r.candidates.filter((e=>e.value!==a));r={...r,candidates:n},t.cells[e]=r}if(!t.isGenerating)for(const r of e.adjacentIndexes.all){let e=t.cells[r];const n=e.candidates.filter((e=>e.value!==a));e={...e,candidates:n},t.cells[r]=e}return t},de=e=>{const t=Array(6);for(let r=0;r<6;r++)t[r]=6*e+r;return t},le=e=>{const t=Array(6);for(let r=0;r<6;r++)t[r]=6*r+e;return t},ce=e=>{const t=Array(6);for(let r=0;r<6;r++){const n=e%2,s=Math.floor(e/2),a=r%3,o=Math.floor(r/3);t[r]=3*n+12*s+a+6*o}return t},pe=e=>{const t=new Set;for(let r=0;r<36;r++){const n=e.cells[r],s=n.value?[n.value]:n.candidates.map((e=>e.value));if(!s)return!1;for(let e=0;e<s.length;e++){const r=6*n.row+s[e],a=36+6*n.column+s[e],o=72+6*n.box+s[e];t.add(r).add(a).add(o)}}return 108===t.size},ue=e=>{const t=[e];let r=0;const n=e.random.shuffledIndexArray(36);for(let s=0;s<36;s++){const a=n[s],o=ae(e.cells[a]);if(e=ie(o,e),pe(e))t.push(e);else{let r=e.cells[a];for(;!r.candidates.length;)r=(e=t.pop()).cells[n[--s]];r.value=0,(e=t.slice(-1)[0]).cells[r.index]=r,--s}if(++r>1e4)return ue(t[0])}return e},fe=(e,t)=>{const r=e.cells[t],n=oe(r),s=[];for(const t of n){let r=ie(t,e);pe(r)&&(r=L(t,r),U(r)&&s.push(r))}return s},he=e=>{let t=0,r=[e];for(let e=0;e<36;e++){t+=r.length;const e=[];for(const t of r){const r=[...t.typeIndexes.vacant].sort(((e,r)=>{const n=t.cells[e].candidates.length,s=t.cells[r].candidates.length;return n>s?1:n<s?-1:t.random.shuffleArray([1,-1])[0]}));e.push(...fe(t,r[0]))}r=e}return{grids:r,rawEntropy:t}},ge=e=>{const t=(e=g(xe,ye)(e)).random.iterate();for(const r of e.adjacencyIDs.optional){const n=k(r);e=e.random.iterate()>t?P(n,e):S(n,e)}return e},xe=e=>{const t=[];for(const r of e.typeIndexes.imposter){const n=e.cells[r];for(const s of n.adjacentIndexes.optional){const n=k(r,s),a=S(n,e);we(a)?(e=a,t.push(n)):e=P(n,e)}}for(const r of t){const t=z(r,e);U(t)&&(e=t)}return e},ye=e=>{const t=[];for(const r of e.typeIndexes.worker){const n=e.cells[r],s=n.adjacentIndexes.type.worker.filter((e=>n.adjacentIndexes.optional.includes(e)));for(const n of s){const s=k(r,n),a=S(s,e);we(a)?(e=a,t.push(s)):e=P(s,e)}}for(const r of t)e=z(r,e);return e},we=e=>{for(const t of e.cells)if(t.type===E.imposter){if(new Set(t.adjacentIndexes.all.map((t=>e.cells[t].value))).size<2)return!1}return 36===R(e,E.vacant,0,!0).length},me=e=>{let t=e;for(const r of e.cells)for(const n of r.adjacentIndexes.all){if(e.cells[n].value===r.value){const e=k(n,r.index);t=S(e,t)}}return t},ve=e=>{const t=Array.from({length:36},((t,r)=>Q(r,e))),r={detective:[],worker:[],imposter:[],vacant:e.shuffledIndexArray(36)},n=new Set;t.forEach((e=>{e.adjacentIndexes.all.forEach((t=>{const r=k(e.index,t);n.add(r.id)}))}));return{cells:t,typeIndexes:r,adjacencyIDs:{required:new Set,optional:n,deleted:new Set},random:e,isGenerating:!0}},Ie=e=>{let t,r,n=0;do{t=g(ve,ue,me)(e);do{if(r=_(t),++n>85){for(let t=0;t<100*Math.random();t++)e.iterate();return Ie(e)}}while(!B(r));t=g(ge,K)(r)}while(!U(t));const s=g(ne,he)(t),{rawEntropy:a}=s;if(1!==s.grids.length||!be(t,s.grids[0])){for(let t=0;t<100*Math.random();t++)e.iterate();return Ie(e)}return t=g(re,se)(t),{grid:t,rawEntropy:a}},be=(e,t)=>!0,je=e=>{const t=new h({size:11});for(let r=0;r<85;r++){const n=e.adjacencyIDs.required.has(r);t.write(n?1:0)}return t},Se=e=>{const t={required:new Set,optional:new Set,deleted:new Set};for(let r=0;r<85;r++)e.read(1)?t.required.add(r):t.deleted.add(r);return t},ze=e=>{let t=new h({size:3});const{value:r,clientValue:n,hints:s}=e,a=[r,n,...s.detective,...s.worker];for(const e of a)t.write(e,{size:3});if(6!==e.candidates.length){t.write(1,{size:1});const r=e.candidates.map((({value:e})=>e));let n=0;for(let e=0;e<6;e++)r.includes(e+1)&&(n|=1<<e);t.write(n,{size:6})}else t.write(0,{size:1});const o=Math.ceil(t.writePointer/8);return t=t.copy({target:new h({size:o}),sourceEnd:t.writePointer}),t},Pe=(e,t)=>{const r=v(t),n={index:t,row:I(t),column:b(t),box:j(t),candidates:[],value:e.read(3),clientValue:e.read(3),type:E.vacant,hints:{detective:[e.read(3)],worker:[e.read(3),e.read(3)],imposter:[]},adjacentIndexes:{all:r,required:[],optional:r,type:{detective:[],worker:[],imposter:[],vacant:[]}}};n.type=n.hints.detective.includes(n.value)?E.detective:n.hints.worker.includes(n.value)?E.worker:E.imposter,n.hints.imposter=[1,2,3,4,5,6].filter((e=>!n.hints.detective.includes(e)&&!n.hints.worker.includes(e)));let s=parseInt("111111",2);e.read(1)&&(s=e.read(6));for(let e=0;e<6;e++)s<<31-e>>>31&&n.candidates.push(ke(n,e+1));return{...n}},ke=(e,t)=>({value:t,type:e.hints.detective.includes(t)?E.detective:e.hints.worker.includes(t)?E.worker:E.imposter}),Ee=e=>{let t=new h({size:128});for(const r of e.cells){const e=ze(r);e.copy({target:t,sourceEnd:e.writePointer})}const r=je(e);r.copy({target:t,sourceEnd:r.writePointer});const n=Math.ceil(t.writePointer/8);return t=t.copy({target:new h({size:n}),sourceEnd:t.writePointer}),t},Ae=(e,t)=>{const r={detective:[],worker:[],imposter:[],vacant:[]},n=[];for(let t=0;t<36;t++){const s=Pe(e,t);r[s.type].push(t),n.push(s)}n.forEach((e=>{e.adjacentIndexes.all.forEach((t=>{const{type:r}=n[t];e.adjacentIndexes.type[r].push(t)}))}));const s=Se(e);let a={cells:n,typeIndexes:r,adjacencyIDs:{required:new Set,optional:new Set(Array.from({length:85},((e,t)=>t))),deleted:new Set},random:new f(t),isGenerating:!1};for(const e of a.adjacencyIDs.optional)a=s.required.has(e)?P(k(e),a):S(k(e),a);return a=se(a),a},$e=e=>{let t=new h({size:128});t.writeString(e.version.puzzle),t.writeString(e.version.repository),t.writeAbsolute(e.seed);const r=Ee(e.grid);r.copy({target:t,sourceEnd:r.writePointer}),t.writeAbsolute(e.rawEntropy),t.write(e.normalizedEntropy,{size:10}),t.write(e.uniformEntropy,{size:10});const n=Math.ceil(t.writePointer/8);return t=t.copy({target:new h({size:n}),sourceEnd:t.writePointer}),t.toString()},Re="1.0.0",Me={beginner:"beginner",easy:"easy",medium:"medium",hard:"hard",expert:"expert"},Le=()=>{const t=new x("undefined"==typeof document?require("url").pathToFileURL(__filename).href:n&&n.src||new URL("index.cjs",document.baseURI).href).absolutePath("../../../../package.json"),{packageObject:r,packageError:a}=((t="package.json")=>{const r=e=>{throw new s({name:"PackageJsonError",message:"Error encountered parsing repository package.json file",path:`${process.cwd()}/${t}`,detail:e.message,"caller-stack":e.stack})};let n;try{n=JSON.parse(e.readFileSync(t).toString())}catch(e){r(e)}return{packageObject:n,packageError:r}})(t),{version:o}=r;if(!o){a(new Error("Version unset or unrecognized, no package version found"))}return o},Ge=e=>{console.log(e);const t=512+256*(Math.log(e)-6.94);return Math.min(Math.max(Math.round(t),0),1024)},Ce=e=>{const t=u({upper:e,mean:512,stdDev:187});return Math.round(1024*t)},De=e=>Math.ceil(e/10.24),qe=e=>e<=20?Me.beginner:e<=40?Me.easy:e<=60?Me.medium:e<=80?Me.hard:Me.expert,_e=(e,t)=>{const r=[];for(let n=0;n<6;n++){const s=6*t+n,a=e.cells[s],[o]=a.hints.detective,i=[o===a.value?"(":" ",o===a.value?")":" "];let d=`${a.type===E.vacant?"V  ":""}${i[0]}${o||0}${i[1]}`.padStart(7);d=d.padEnd(11);const l=n?"":"  ";r.push(`${l}┌${d}┐  `)}console.log(r.join(""))},Te=(e,t)=>{const r=[];for(let n=0;n<6;n++){const s=6*t+n,a=e.cells[s],[o,i]=a.hints.worker,d=[o===a.value?"(":" ",o===a.value?")":" ",i===a.value?"(":" ",i===a.value?")":" "],l=`${d[0]}${o||0}${d[1]}`,c=`${d[2]}${i||0}${d[3]}`;let p=l.padStart(5);p+=` ${c}`,p=p.padEnd(11);const u=a.adjacentIndexes.all.includes(s+1)?"──":"  ",f=n?"":"  ";r.push(`${f}│${p}│${u}`)}console.log(r.join(""))},Oe=(e,t)=>{const r=[];for(let n=0;n<6;n++){const s=6*t+n,a=e.cells[s],[o,i,d]=a.hints.imposter,l=[o===a.value?"(":" ",o===a.value?")":" ",i===a.value?"(":" ",i===a.value?")":" ",d===a.value?"(":" ",d===a.value?")":" "],c=`${l[0]}${o||0}${l[1]}`,p=`${l[2]}${i||0}${l[3]}`,u=`${l[4]}${d||0}${l[5]}`;let f=c.padStart(3);f+=` ${p} ${u}`,f=f.padEnd(11);const h=n?"":"  ";r.push(`${h}└${f}┘  `)}console.log(r.join(""))},Ne=(e,t)=>{const r=[];for(let n=0;n<6;n++){const s=6*t+n,a=e.cells[s],o=a.adjacentIndexes.all.includes(s+5),i=a.adjacentIndexes.all.includes(s+6);let d=o?" ╱":"  ";d=d.padEnd(8),d+=i?"│":" ";const l=d.padEnd(15);r.push(`${l}`)}console.log(r.join("")),r.forEach(((e,t)=>{r[t]=`${e[1]} ${e.slice(2)}`})),console.log(r.join(""))};exports.CELL_TYPES=E,exports.IMPOSTORI_GRADES=Me,exports.PUZZLE_VERSION=Re,exports.addCellAdjacency=w,exports.addGridAdjacency=z,exports.allContinuosTypeIndexes=M,exports.completedGridTypes=B,exports.continuosTypeIndexes=R,exports.deserializeAdjacencies=Se,exports.deserializeCell=Pe,exports.deserializeGrid=Ae,exports.deserializeImpostori=e=>{const t=h.from(e),r={version:{puzzle:t.readString(),repository:t.readString()},seed:t.readAbsolute(),grid:Ae(t,0),rawEntropy:t.readAbsolute(),normalizedEntropy:t.read(10),uniformEntropy:t.read(10)},n=De(r.uniformEntropy),s=qe(n);return{...r,rating:n,grade:s,serializedString:e}},exports.fillCellHints=Y,exports.fillCellType=A,exports.fillCellValue=ae,exports.fillGridHints=K,exports.fillGridTypes=_,exports.fillGridValues=ue,exports.forkCellValue=oe,exports.generateEmptyCell=Q,exports.generateEmptyGrid=ve,exports.generateGrid=Ie,exports.generateImpostori=e=>{const t=new f(e),{grid:r,rawEntropy:n}=Ie(t),s={version:{puzzle:Re,repository:Le()},seed:t.config.seed,grid:r,rawEntropy:n};return s.normalizedEntropy=Ge(s.rawEntropy),s.uniformEntropy=Ce(s.normalizedEntropy),s.rating=De(s.uniformEntropy),s.grade=qe(s.rating),s.grid.random=new f(s.seed),{...s,serializedString:$e(s)}},exports.getAdjacencyData=k,exports.getAdjacentIndexes=v,exports.getBox=j,exports.getColumn=b,exports.getGradeString=qe,exports.getRating=De,exports.getRow=I,exports.hardResetCell=e=>X(e,!0),exports.hardResetGrid=ne,exports.printGrid=e=>{for(let t=0;t<6;t++)_e(e,t),Te(e,t),Oe(e,t),Ne(e,t)},exports.propagateCellType=L,exports.propagateCellValue=ie,exports.pruneGridAdjacencies=ge,exports.removeCellAdjacency=y,exports.removeGridAdjacency=S,exports.removeTwins=me,exports.requireCellAdjacency=m,exports.requireGridAdjacency=P,exports.resetCell=X,exports.resetGrid=te,exports.serializeAdjacencies=je,exports.serializeCell=ze,exports.serializeGrid=Ee,exports.serializeImpostori=$e,exports.softResetCell=e=>X(e,!1),exports.softResetGrid=re,exports.solveCell=fe,exports.solveGrid=he,exports.sortCell=ee,exports.sortGrid=se,exports.validateGridTypes=U,exports.validateGridValues=pe;
